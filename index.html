<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# â†’ Mermaid Viz (No Subgraph)</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
    textarea { width: 100%; height: 120px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; color: white; }
    .btn-add { background: #007bff; }
    .btn-add:hover { background: #0056b3; }
    .btn-save { background: #28a745; } 
    .btn-reset { background: #dc3545; }
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 500px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
  </style>
</head>
<body>

  <h1>C# â†’ Mermaid Visualizer (No Subgraph)</h1>
  <p>Namespaceã®æ ã‚’ä½¿ã‚ãšã€ã‚·ãƒ³ãƒ—ãƒ«ã«ã‚¯ãƒ©ã‚¹å›³ã‚’æç”»ã—ã¾ã™ã€‚</p>
  
  <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘"></textarea>
  
  <div class="controls">
    <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
    <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ (Save)</button>
    <button onclick="resetAll()" class="btn-reset">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
    <span id="statusMsg" style="display:none; color:#28a745; font-weight:bold; margin-left:10px;">ä¿å­˜ã—ã¾ã—ãŸï¼</span>
  </div>

  <div id="diagramContainer"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let fullSourceCode = "";

  window.addEventListener('load', async () => {
    const savedCode = localStorage.getItem('mermaid_csharp_viz_nosub');
    if (savedCode) {
      fullSourceCode = savedCode;
      await analyzeAndRender(fullSourceCode);
    }
  });

  window.addCode = async function() {
    const input = document.getElementById('codeInput');
    if(!input.value.trim()) return;
    fullSourceCode += "\n" + input.value;
    await analyzeAndRender(fullSourceCode);
    input.value = "";
  };

  window.saveToStorage = function() {
    localStorage.setItem('mermaid_csharp_viz_nosub', fullSourceCode);
    const msg = document.getElementById('statusMsg');
    msg.style.display = 'inline';
    setTimeout(() => { msg.style.display = 'none'; }, 2000);
  };

  window.resetAll = async function() {
    if(!confirm("ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
    fullSourceCode = "";
    localStorage.removeItem('mermaid_csharp_viz_nosub');
    document.getElementById('diagramContainer').innerHTML = "";
  };

  async function analyzeAndRender(source) {
    let cleanSource = removeComments(source);
    
    // Namespaceè§£æç”¨ã®å¤‰æ•°
    const namespaceBlocks = new Map();
    namespaceBlocks.set("Global", []);
    
    const nsRegex = /namespace\s+([\w\.]+)/g;
    let match;
    
    // 1. NamespaceæŠ½å‡º (ã‚³ãƒ¼ãƒ‰ã®åˆ‡ã‚Šå‡ºã—)
    while ((match = nsRegex.exec(cleanSource)) !== null) {
      const nsName = match[1];
      const openBraceIndex = cleanSource.indexOf("{", match.index);
      const semiColonIndex = cleanSource.indexOf(";", match.index);

      if (openBraceIndex === -1 || (semiColonIndex !== -1 && semiColonIndex < openBraceIndex)) {
        continue;
      }

      const blockEnd = findBlockEnd(cleanSource, openBraceIndex);
      if (blockEnd !== -1) {
        const body = cleanSource.substring(openBraceIndex + 1, blockEnd);
        if (!namespaceBlocks.has(nsName)) namespaceBlocks.set(nsName, []);
        namespaceBlocks.get(nsName).push(body);
        
        // æŠ½å‡ºã—ãŸéƒ¨åˆ†ã‚’ç©ºç™½ç½®æ›
        const padding = " ".repeat(blockEnd - match.index + 1);
        cleanSource = cleanSource.substring(0, match.index) + padding + cleanSource.substring(blockEnd + 1);
        
        nsRegex.lastIndex = blockEnd + 1;
      }
    }
    // æ®‹ã‚Šã‚’Globalã¸
    namespaceBlocks.get("Global").push(cleanSource);


    // 2. ã‚¯ãƒ©ã‚¹è§£æ
    const parsedClasses = [];
    const processedClassNames = new Set();

    for (const [nsName, blocks] of namespaceBlocks) {
      blocks.forEach(code => {
        const classRegex = /public\s+(?:static\s+)?class\s+(\w+)(?:\s*:\s*([\w, ]+))?/g;
        let cMatch;
        while ((cMatch = classRegex.exec(code)) !== null) {
          const className = cMatch[1];
          if (processedClassNames.has(className)) continue; 
          processedClassNames.add(className);

          const inheritanceRaw = cMatch[2];
          const classBodyBlock = extractBlock(code, cMatch.index + cMatch[0].length);
          
          const classData = {
            className: className,
            members: [],
            relations: [],
            parent: null,
            style: ""
          };

          if (className.match(/Manager|Controller|Service/)) classData.style = "fill:#e3f2fd,stroke:#1565c0,stroke-width:2px";
          else if (className.match(/Config|Data|Model|Body|World/)) classData.style = "fill:#fff9c4,stroke:#fbc02d,stroke-width:2px";

          if (inheritanceRaw) {
            classData.parent = inheritanceRaw.split(',')[0].trim().split('<')[0];
          }

          if (classBodyBlock) {
             parseMembers(classBodyBlock, classData);
          }
          parsedClasses.push(classData);
        }
      });
    }

    // 3. Mermaidç”Ÿæˆ
    let def = "classDiagram\n";

    // ã‚¯ãƒ©ã‚¹å®šç¾©ï¼ˆsubgraphã‚’ä½¿ã‚ãšãƒ•ãƒ©ãƒƒãƒˆã«å‡ºåŠ›ï¼‰
    parsedClasses.forEach(c => {
      def += `  class ${c.className} {\n`;
      c.members.forEach(m => def += `    ${m}\n`);
      def += `  }\n`;
      if (c.style) def += `  style ${c.className} ${c.style}\n`;
    });

    // ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æç”»
    parsedClasses.forEach(c => {
      // ç¶™æ‰¿
      if (c.parent && processedClassNames.has(c.parent)) {
        def += `  ${c.parent} <|-- ${c.className}\n`;
      }

      // ä¾å­˜é–¢ä¿‚æ•´ç†
      const relMap = new Map(); 
      c.relations.forEach(r => {
        if (r.target === c.className || !processedClassNames.has(r.target)) return;
        if (!relMap.has(r.target)) relMap.set(r.target, { new: new Set(), use: new Set(), return: new Set() });
        relMap.get(r.target)[r.type].add(r.label);
      });

      relMap.forEach((types, target) => {
        types.new.forEach(l => { types.return.delete(l); types.use.delete(l); });
        types.return.forEach(l => { types.use.delete(l); });

        if (types.new.size > 0) {
           def += `  ${c.className} --> ${target} : new ${Array.from(types.new).join(', ')}\n`;
        }
        if (types.return.size > 0) {
           def += `  ${c.className} --> ${target} : ${Array.from(types.return).join(', ')}\n`;
        }
        if (types.use.size > 0) {
           def += `  ${c.className} ..> ${target} : ${Array.from(types.use).join(', ')}\n`;
        }
      });
    });

    await renderMermaid(def);
  }

  // --- è§£æãƒ­ã‚¸ãƒƒã‚¯ ---
  function parseMembers(body, classData) {
    // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    const pRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
    let pm;
    while ((pm = pRegex.exec(body)) !== null) {
      if (pm[1].includes("class ")) continue;
      classData.members.push(`+${formatType(pm[1])} ${pm[2]}`);
    }

    // ãƒ¡ã‚½ãƒƒãƒ‰
    const mRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
    let mm;
    while ((mm = mRegex.exec(body)) !== null) {
      const retType = formatType(mm[1]);
      const mName = mm[2];
      const args = formatArgs(mm[3]);
      classData.members.push(`+${mName}(${args}) ${retType}`);

      const rawRet = mm[1].split('<')[0].trim().replace('[]','');
      classData.relations.push({ target: rawRet, type: 'return', label: mName });

      const endIdx = mm.index + mm[0].length;
      const mBody = extractBlock(body, endIdx);
      if (mBody) {
        const newMatches = [...mBody.matchAll(/new\s+(\w+)\s*\(/g)];
        newMatches.forEach(m => classData.relations.push({ target: m[1], type: 'new', label: mName }));

        const statMatches = [...mBody.matchAll(/(\w+)\s*\.\w+/g)];
        statMatches.forEach(m => {
           if(!["Math","Debug","Console","MathF","Vector2","Size","List","Dictionary"].includes(m[1])) 
             classData.relations.push({ target: m[1], type: 'use', label: `call ${mName}` });
        });
      }
    }
  }

  // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼ ---
  function findBlockEnd(text, openIndex) {
    let depth = 1;
    let i = openIndex + 1;
    while (i < text.length && depth > 0) {
      if (text[i] === '{') depth++;
      else if (text[i] === '}') depth--;
      i++;
    }
    return i - 1;
  }

  function extractBlock(text, start) {
    const openIndex = text.indexOf('{', start);
    if (openIndex === -1) return null;
    const endIndex = findBlockEnd(text, openIndex);
    return text.substring(openIndex + 1, endIndex);
  }

  function formatType(raw) {
    let safe = raw.trim().replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
    return escapeGenerics(safe);
  }
  function formatArgs(raw) { return escapeGenerics(raw, true); }

  function escapeGenerics(str, isArgList = false) {
    let res = "", depth = 0;
    for (let i = 0; i < str.length; i++) {
      const c = str[i];
      if (c === '<') { depth++; res += '~'; }
      else if (c === '>') { depth--; res += '~'; }
      else if (c === ',') { res += (depth > 0 ? 'ï¼Œ' : (isArgList ? ' ' : ' ')); }
      else res += c;
    }
    return res;
  }

  function removeComments(str) {
    return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
  }

  async function renderMermaid(def) {
    const container = document.getElementById('diagramContainer');
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
    try { await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); }
    catch(e) { 
        console.error(e); 
        container.innerHTML = `<p style="color:red">Error</p><textarea style="width:100%;height:300px">${def}</textarea>`; 
    }
  }
</script>
</body>
</html>
