<!DOCTYPE html>
<html lang="ja">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  <title>C# â†’ Mermaid Viz (Namespace & Unique)</title>
Â  <script type="module">
Â  Â  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
Â  Â  mermaid.initialize({ startOnLoad: false });
Â  Â  window.mermaid = mermaid;
Â  </script>
Â  <style>
Â  Â  body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
Â  Â  textarea { width: 100%; height: 120px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
Â  Â Â 
Â  Â  .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
Â  Â Â 
Â  Â  button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; color: white; }
Â  Â  .btn-add { background: #007bff; }
Â  Â  .btn-add:hover { background: #0056b3; }
Â  Â  .btn-save { background: #28a745; }Â 
Â  Â  .btn-save:hover { background: #218838; }
Â  Â  .btn-reset { background: #dc3545; }
Â  Â  .btn-reset:hover { background: #c82333; }

Â  Â  .status-msg { font-size: 0.9rem; color: #28a745; display: none; margin-left: 10px; font-weight: bold;}
Â  Â Â 
Â  Â  .legend { font-size: 0.85rem; margin-left: auto; color: #555; display: flex; gap: 10px; }
Â  Â  .legend span { display: flex; align-items: center; gap: 4px; }
Â  Â Â 
Â  Â  #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 500px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
Â  </style>
</head>
<body>

Â  <h1>C# â†’ Mermaid Visualizer (Namespaceå¯¾å¿œç‰ˆ)</h1>
Â  <p>Namespaceã”ã¨ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã¨ã€é‡è¤‡ã‚¯ãƒ©ã‚¹ã®è‡ªå‹•é™¤å¤–ã‚’è¡Œã„ã¾ã™ã€‚</p>
Â Â 
Â  <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘"></textarea>
Â Â 
Â  <div class="controls">
Â  Â  <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
Â  Â  <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ (Save)</button>
Â  Â  <button onclick="resetAll()" class="btn-reset">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
Â  Â  <span id="statusMsg" class="status-msg">ä¿å­˜ã—ã¾ã—ãŸï¼</span>
Â  Â Â 
Â  Â  <div class="legend">
Â  Â  Â  <span><b>â”â”â–·</b> new (ç”Ÿæˆ)</span>
Â  Â  Â  <span><b>- - â–·</b> use (ä¾å­˜)</span>
Â  Â  Â  <span><b>â”€â”€â–·</b> ç¶™æ‰¿</span>
Â  Â  </div>
Â  </div>

Â  <div id="diagramContainer"></div>

<script type="module">
Â  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

Â  let fullSourceCode = "";

Â  window.addEventListener('load', async () => {
Â  Â  const savedCode = localStorage.getItem('mermaid_csharp_viz_ns');
Â  Â  if (savedCode) {
Â  Â  Â  fullSourceCode = savedCode;
Â  Â  Â  await analyzeAndRender(fullSourceCode);
Â  Â  }
Â  });

Â  window.addCode = async function() {
Â  Â  const input = document.getElementById('codeInput');
Â  Â  if(!input.value.trim()) return;
Â  Â  fullSourceCode += "\n" + input.value;
Â  Â  await analyzeAndRender(fullSourceCode);
Â  Â  input.value = "";
Â  };

Â  window.saveToStorage = function() {
Â  Â  localStorage.setItem('mermaid_csharp_viz_ns', fullSourceCode);
Â  Â  const msg = document.getElementById('statusMsg');
Â  Â  msg.style.display = 'inline';
Â  Â  setTimeout(() => { msg.style.display = 'none'; }, 2000);
Â  };

Â  window.resetAll = async function() {
Â  Â  if(!confirm("ç¾åœ¨ã®å›³ã¨ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) return;
Â  Â  fullSourceCode = "";
Â  Â  localStorage.removeItem('mermaid_csharp_viz_ns');
Â  Â  document.getElementById('diagramContainer').innerHTML = "";
Â  };

Â  async function analyzeAndRender(source) {
Â  Â  let cleanSource = removeComments(source);
Â  Â Â 
Â  Â  // ã‚¯ãƒ©ã‚¹åã®ä¸€æ„æ€§ã‚’ä¿ã¤ãŸã‚ã®Setï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
Â  Â  const processedClasses = new Set();
Â  Â Â 
Â  Â  // Namespaceã”ã¨ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç®¡ç†ã™ã‚‹Map
Â  Â  // key: namespaceå, value: ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã®é…åˆ—
Â  Â  const namespaceMap = new Map();
Â  Â  namespaceMap.set("Global", []); // Namespaceå¤–ã®ã‚¯ãƒ©ã‚¹ç”¨

Â  Â  // 1. ãƒ–ãƒ­ãƒƒã‚¯å½¢å¼ã®Namespaceã‚’æŠ½å‡º (namespace X { ... })
Â  Â  // Regex: namespace Name { body }
Â  Â  const nsBlockRegex = /namespace\s+([\w\.]+)\s*/g;
Â  Â  let match;
Â  Â Â 
Â  Â  // æ–‡å­—åˆ—ã‚’èµ°æŸ»ã—ã¦Namespaceãƒ–ãƒ­ãƒƒã‚¯ã‚’åˆ‡ã‚Šå‡ºã™
Â  Â  // extractBlockã‚’ä½¿ã†ãŸã‚ã€Regexãƒ«ãƒ¼ãƒ—ã§ã¯ãªãæ‰‹å‹•ã§æ¤œç´¢ä½ç½®ã‚’é€²ã‚ã‚‹
Â  Â  let cursor = 0;
Â  Â  while (cursor < cleanSource.length) {
Â  Â  Â  // æ¬¡ã® "namespace" ã‚’æ¢ã™
Â  Â  Â  const nsIndex = cleanSource.indexOf("namespace ", cursor);
Â  Â  Â  if (nsIndex === -1) break; // ã‚‚ã†ãªã„

Â  Â  Â  // namespaceã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¾Œã® "{" ã‚’æ¢ã™
Â  Â  Â  const openBraceIndex = cleanSource.indexOf("{", nsIndex);
Â  Â  Â  const semiColonIndex = cleanSource.indexOf(";", nsIndex);
Â  Â  Â Â 
Â  Â  Â  // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ— (namespace X;) ã‹ ãƒ–ãƒ­ãƒƒã‚¯ (namespace X { }) ã‹åˆ¤å®š
Â  Â  Â  // { ã‚ˆã‚Šå…ˆã« ; ãŒæ¥ãŸã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ï¼ˆã‚ã‚‹ã„ã¯ { ãŒãªã„ï¼‰
Â  Â  Â  if (semiColonIndex !== -1 && (openBraceIndex === -1 || semiColonIndex < openBraceIndex)) {
Â  Â  Â  Â  Â // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—: namespace X;
Â  Â  Â  Â  Â // æœ¬å½“ã¯ã“ã‚Œä»¥é™ã®å…¨ã‚³ãƒ¼ãƒ‰ãŒå¯¾è±¡ã ãŒã€ç°¡æ˜“çš„ã«ã€Œã“ã“ã‹ã‚‰æœ«å°¾ã¾ã§ã€ã‚’ãã®Namespaceæ‰±ã„ã«ã™ã‚‹
Â  Â  Â  Â  Â // ãŸã ã—ã€è¤‡æ•°è²¼ã‚Šä»˜ã‘ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®å®Ÿè£…ã¯
Â  Â  Â  Â  Â // ã€Œè²¼ã‚Šä»˜ã‘å˜ä½ã€ã§ç®¡ç†ã—ãªã„ã¨é›£ã—ã„ã€‚
Â  Â  Â  Â  Â // ä»Šå›ã¯ç°¡æ˜“çš„ã«ã€ŒGlobalã€æ‰±ã„ã«ã™ã‚‹ã‹ã€æ­£è¦è¡¨ç¾ã§åå‰ã ã‘å–ã‚‹ã€‚
Â  Â  Â  Â  Â // â€»è¤‡é›‘åŒ–å›é¿ã®ãŸã‚ã€ä»Šå›ã¯ { } ãƒ–ãƒ­ãƒƒã‚¯å½¢å¼ã‚’å„ªå…ˆã—ã¦å‡¦ç†ã—ã€ãƒãƒƒãƒã—ãªã„éƒ¨åˆ†ã¯Globalã«æ®‹ã™
Â  Â  Â  Â  Â cursor = semiColonIndex + 1;Â 
Â  Â  Â  Â  Â continue;
Â  Â  Â  }

Â  Â  Â  if (openBraceIndex !== -1) {
Â  Â  Â  Â  // åå‰ã‚’å–å¾—
Â  Â  Â  Â  const nsName = cleanSource.substring(nsIndex + 10, openBraceIndex).trim();
Â  Â  Â  Â Â 
Â  Â  Â  Â  // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­èº«ã‚’æŠ½å‡º
Â  Â  Â  Â  const body = extractBlock(cleanSource, openBraceIndex + 1); // +1ä¿®æ­£: {ã®æ¬¡ã‹ã‚‰
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (body) {
Â  Â  Â  Â  Â  Â if (!namespaceMap.has(nsName)) namespaceMap.set(nsName, []);
Â  Â  Â  Â  Â  Â namespaceMap.get(nsName).push(body);

Â  Â  Â  Â  Â  Â // å…ƒã®æ–‡å­—åˆ—ã‹ã‚‰ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’é™¤å»ï¼ˆç½®æ›ï¼‰ã—ã¦Globalã«æ®‹ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
Â  Â  Â  Â  Â  Â // ãŸã ã—ä½ç½®ãŒãšã‚Œã‚‹ã®ã§ã€é™¤å»ã™ã‚‹éƒ¨åˆ†ã¯ç©ºç™½ã§åŸ‹ã‚ã‚‹ã‹ã€
Â  Â  Â  Â  Â  Â // ã€ŒæŠ½å‡ºã—ãŸã‚‚ã®ãƒªã‚¹ãƒˆã€ã ã‘ã§å‡¦ç†ã‚’é€²ã‚ã‚‹ã€‚
Â  Â  Â  Â  Â  Â // ã“ã“ã§ã¯ã€ŒnamespaceMapã€ã«å…¥ã‚ŒãŸä¸Šã§ã€Globalè§£æç”¨ã«å…ƒã®æ–‡å­—åˆ—ã‹ã‚‰æ¶ˆã™ï¼ˆç©ºç™½åŒ–ï¼‰
Â  Â  Â  Â  Â  Â const fullBlockLength = (cleanSource.indexOf("}", openBraceIndex) - nsIndex) + 1;Â 
Â  Â  Â  Â  Â  Â // æ­£ç¢ºãªçµ‚äº†ä½ç½®ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«å†è¨ˆç®—
Â  Â  Â  Â  Â  Â // extractBlockã¯ä¸­èº«ã‚’è¿”ã™ã®ã§ã€å…¨ä½“é•·ã‚’çŸ¥ã‚‹ã«ã¯ä¸­èº«é•·+2({})+nameé•·ãªã©ã‚’è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒé¢å€’
Â  Â  Â  Â  Â  Â // ç°¡ä¾¿æ³•: æŠ½å‡ºæ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯ã—ã€Globalè§£ææ™‚ã«ã¯ä½¿ã‚ãªã„
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â // ä»Šå›ã¯ã€ŒæŠ½å‡ºã—ãŸéƒ¨åˆ†ã‚’ç©ºç™½ã«ç½®æ›ã€ã—ã¦Globalã«æ®‹ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
Â  Â  Â  Â  Â  Â const blockStart = nsIndex;
Â  Â  Â  Â  Â  Â // bodyã¯ä¸­èº«ã ã‘ãªã®ã§ã€å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã§ã®çµ‚äº†ä½ç½®ã‚’æ¢ã™å¿…è¦ãŒã‚ã‚‹
Â  Â  Â  Â  Â  Â // extractBlockãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨ã—ã¦çµ‚äº†ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
Â  Â  Â  Â  Â  Â const blockEnd = findBlockEnd(cleanSource, openBraceIndex);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â // ç½®æ›ï¼ˆæ–‡å­—åˆ—æ“ä½œã¯ä¸å¤‰ãªã®ã§æ–°ã—ã„æ–‡å­—åˆ—ã‚’ä½œã‚‹ï¼‰
Â  Â  Â  Â  Â  Â const before = cleanSource.substring(0, blockStart);
Â  Â  Â  Â  Â  Â const after = cleanSource.substring(blockEnd + 1);
Â  Â  Â  Â  Â  Â // ç½®æ›ã—ãŸåˆ†ã€æ–‡å­—æ•°ãŒæ¸›ã‚‹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç‹‚ã†ã®ã§ã€åŒã˜é•·ã•ã®ç©ºç™½ã§åŸ‹ã‚ã‚‹
Â  Â  Â  Â  Â  Â const padding = " ".repeat(blockEnd - blockStart + 1);
Â  Â  Â  Â  Â  Â cleanSource = before + padding + after;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â cursor = blockEnd + 1;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â cursor = openBraceIndex + 1;
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  cursor = nsIndex + 9;
Â  Â  Â  }
Â  Â  }

Â  Â  // æ®‹ã£ãŸã‚³ãƒ¼ãƒ‰ã¯Global
Â  Â  namespaceMap.get("Global").push(cleanSource);


Â  Â  let mermaidDef = "classDiagram\n";

Â  Â  // --- å„Namespaceã”ã¨ã«ã‚¯ãƒ©ã‚¹ã‚’è§£æ ---
Â  Â  const allClassBlocks = []; // å¾Œã§ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è§£æã«ä½¿ã†

Â  Â  // Namespaceã®å‡ºåŠ›é †åºåˆ¶å¾¡ï¼ˆGlobalã‚’æœ€å¾Œã«å›ã™ãªã©ï¼‰
Â  Â  for (const [nsName, codeBlocks] of namespaceMap) {
Â  Â  Â  if (codeBlocks.join("").trim() === "") continue;

Â  Â  Â  let nsDef = "";
Â  Â  Â Â 
Â  Â  Â  codeBlocks.forEach(code => {
Â  Â  Â  Â  // ã‚¯ãƒ©ã‚¹å®šç¾©æŠ½å‡º
Â  Â  Â  Â  const regex = /public\s+(?:static\s+)?class\s+(\w+)(?:\s*:\s*([\w, ]+))?/g;
Â  Â  Â  Â  let match;
Â  Â  Â  Â  while ((match = regex.exec(code)) !== null) {
Â  Â  Â  Â  Â  const className = match[1];
Â  Â  Â  Â  Â  const inheritanceRaw = match[2];

Â  Â  Â  Â  Â  // é‡è¤‡ãƒã‚§ãƒƒã‚¯: æ—¢ã«å‡¦ç†æ¸ˆã¿ã®ã‚¯ãƒ©ã‚¹ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
Â  Â  Â  Â  Â  if (processedClasses.has(className)) continue;
Â  Â  Â  Â  Â  processedClasses.add(className);

Â  Â  Â  Â  Â  nsDef += `Â  Â  class ${className}\n`;
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // ã‚¹ã‚¿ã‚¤ãƒ«
Â  Â  Â  Â  Â  if (className.match(/Manager|Controller|Service/)) nsDef += `Â  Â  style ${className} fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n`;
Â  Â  Â  Â  Â  else if (className.match(/Config|Data|Model|Body|World/)) nsDef += `Â  Â  style ${className} fill:#fff9c4,stroke:#fbc02d,stroke-width:2px\n`;

Â  Â  Â  Â  Â  // ç¶™æ‰¿é–¢ä¿‚ (Namespaceå¤–ã®ã‚¯ãƒ©ã‚¹ã¨ã®é–¢ä¿‚ã‚‚è€ƒæ…®ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯å®šç¾©ã ã‘è¿½åŠ )
Â  Â  Â  Â  Â  if (inheritanceRaw) {
Â  Â  Â  Â  Â  Â  Â const parents = inheritanceRaw.split(',').map(p => p.trim().split('<')[0]);
Â  Â  Â  Â  Â  Â  Â parents.forEach(p => {
Â  Â  Â  Â  Â  Â  Â  Â // è¦ªã‚¯ãƒ©ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã¯å…¨è§£æå¾Œã˜ã‚ƒãªã„ã¨ç¢ºå®šã—ãªã„ãŒã€Mermaidã¯æœªå®šç¾©ãƒãƒ¼ãƒ‰ã‚‚æç”»ã—ã¦ãã‚Œã‚‹ã®ã§OK
Â  Â  Â  Â  Â  Â  Â  Â // ãŸã ã—ã€subgraphå¤–ã¸ã®ç·šã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€å®šç¾©ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã§è¡Œã†ã®ãŒå®‰å…¨
Â  Â  Â  Â  Â  Â  Â  Â // ä¸€æ—¦ã“ã“ã§ã¯é…åˆ—ã«ä¿å­˜ã—ã¦ãŠã
Â  Â  Â  Â  Â  Â  Â  Â allClassBlocks.push({ type:'inheritance', child: className, parent: p });
Â  Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // ã‚¯ãƒ©ã‚¹ã®ä¸­èº«ã‚’æŠ½å‡ºã—ã¦ä¿å­˜ï¼ˆãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è§£æç”¨ï¼‰
Â  Â  Â  Â  Â  const body = extractBlock(code, match.index + match[0].length);
Â  Â  Â  Â  Â  if (body) {
Â  Â  Â  Â  Â  Â  allClassBlocks.push({ type:'class', className, body });
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  if (nsDef.trim() !== "") {
Â  Â  Â  Â  // Globalä»¥å¤–ã¯subgraphã§å›²ã‚€
Â  Â  Â  Â  if (nsName !== "Global") {
Â  Â  Â  Â  Â  mermaidDef += `Â  subgraph "${nsName}"\n`;
Â  Â  Â  Â  Â  mermaidDef += `Â  Â  direction TB\n`; // Top to Bottom
Â  Â  Â  Â  Â  mermaidDef += nsDef;
Â  Â  Â  Â  Â  mermaidDef += `Â  end\n`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  mermaidDef += nsDef; // Globalã¯ãã®ã¾ã¾
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  // --- ãƒ¡ã‚½ãƒƒãƒ‰ãƒ»ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ»ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è§£æ ---
Â  Â  allClassBlocks.forEach(item => {
Â  Â  Â  // ç¶™æ‰¿é–¢ä¿‚ã®å‡ºåŠ›
Â  Â  Â  if (item.type === 'inheritance') {
Â  Â  Â  Â  Â // è¦ªã‚¯ãƒ©ã‚¹ãŒprocessedClassesã«ã‚ã‚‹å ´åˆã®ã¿æç”»ï¼ˆãƒã‚¤ã‚ºé˜²æ­¢ï¼‰
Â  Â  Â  Â  Â if (processedClasses.has(item.parent)) {
Â  Â  Â  Â  Â  Â  mermaidDef += `Â  ${item.parent} <|-- ${item.child}\n`;
Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â return;
Â  Â  Â  }

Â  Â  Â  // ã‚¯ãƒ©ã‚¹å®šç¾©å‡¦ç†
Â  Â  Â  const owner = item.className;
Â  Â  Â  const body = item.body;

Â  Â  Â  // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
Â  Â  Â  const propRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
Â  Â  Â  let pMatch;
Â  Â  Â  while ((pMatch = propRegex.exec(body)) !== null) {
Â  Â  Â  Â  if (pMatch[1].includes("class ")) continue;Â 
Â  Â  Â  Â  mermaidDef += `Â  ${owner} : +${formatType(pMatch[1])} ${pMatch[2]}\n`;
Â  Â  Â  }

Â  Â  Â  // ãƒ¡ã‚½ãƒƒãƒ‰ & ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
Â  Â  Â  const methodRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
Â  Â  Â  let mMatch;
Â  Â  Â  const relations = new Map(); // Target -> { solid: Set, dashed: Set }

Â  Â  Â  while ((mMatch = methodRegex.exec(body)) !== null) {
Â  Â  Â  Â  const [_, retRaw, mName, argsRaw] = mMatch;
Â  Â  Â  Â  const dRet = formatType(retRaw);
Â  Â  Â  Â  const dArgs = formatArgs(argsRaw);
Â  Â  Â  Â Â 
Â  Â  Â  Â  mermaidDef += `Â  ${owner} : +${mName}(${dArgs}) ${dRet}\n`;

Â  Â  Â  Â  // æˆ»ã‚Šå€¤
Â  Â  Â  Â  const rawRetClass = retRaw.split('<')[0].trim().replace('[]','');
Â  Â  Â  Â  if (processedClasses.has(rawRetClass) && rawRetClass !== owner) {
Â  Â  Â  Â  Â  Â addRel(relations, rawRetClass, 'solid', mName);
Â  Â  Â  Â  }

Â  Â  Â  Â  // å†…éƒ¨ã‚³ãƒ¼ãƒ‰è§£æ
Â  Â  Â  Â  const endIdx = mMatch.index + mMatch[0].length;
Â  Â  Â  Â  const mBody = extractBlock(body, endIdx); // extractBlockã¯æ±ç”¨ãªã®ã§ã“ã“ã§ã‚‚ä½¿ãˆã‚‹
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (mBody) {
Â  Â  Â  Â  Â  Â processedClasses.forEach(target => {
Â  Â  Â  Â  Â  Â  Â if (target === owner) return;
Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â if (new RegExp(`new\\s+${target}\\s*\\(`).test(mBody)) {
Â  Â  Â  Â  Â  Â  Â  Â addRel(relations, target, 'solid', `new ${mName}`);
Â  Â  Â  Â  Â  Â  Â  Â // newãŒã‚ã‚‹ãªã‚‰å˜ãªã‚‹returnã¨ã—ã¦ã®è¡¨ç¤ºã¯æ¶ˆã™
Â  Â  Â  Â  Â  Â  Â  Â removeRel(relations, target, 'solid', mName);
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â else if (new RegExp(`\\b${target}\\s*\\.\\w+`).test(mBody)) {
Â  Â  Â  Â  Â  Â  Â  Â addRel(relations, target, 'dashed', `call ${mName}`);
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â else if (new RegExp(`\\b${target}\\b`).test(mBody)) {
Â  Â  Â  Â  Â  Â  Â  Â addRel(relations, target, 'dashed', mName);
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // æç”»
Â  Â  Â  relations.forEach((types, target) => {
Â  Â  Â  Â  if (types.solid.size > 0) {
Â  Â  Â  Â  Â  mermaidDef += `Â  ${owner} --> ${target} : ${Array.from(types.solid).join(', ')}\n`;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // é‡è¤‡é™¤å» (solidã«ã‚ã‚‹ã‚‚ã®ã¯dashedã‹ã‚‰æ¶ˆã™)
Â  Â  Â  Â  types.dashed.forEach(label => {
Â  Â  Â  Â  Â  Â  const rawLabel = label.replace('call ', '').replace('new ', '');
Â  Â  Â  Â  Â  Â  let isDuplicated = false;
Â  Â  Â  Â  Â  Â  types.solid.forEach(s => { if(s.includes(rawLabel)) isDuplicated = true; });
Â  Â  Â  Â  Â  Â  if(isDuplicated) types.dashed.delete(label);
Â  Â  Â  Â  });

Â  Â  Â  Â  if (types.dashed.size > 0) {
Â  Â  Â  Â  Â  mermaidDef += `Â  ${owner} ..> ${target} : ${Array.from(types.dashed).join(', ')}\n`;
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  });

Â  Â  await renderMermaid(mermaidDef);
Â  }

Â  // --- Helpers ---

Â  // { ã®ä½ç½®ã‹ã‚‰å¯¾å¿œã™ã‚‹ } ã®ä½ç½®ã‚’æ¢ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
Â  function findBlockEnd(text, openIndex) {
Â  Â  let depth = 1;
Â  Â  let i = openIndex + 1;
Â  Â  while (i < text.length && depth > 0) {
Â  Â  Â  if (text[i] === '{') depth++;
Â  Â  Â  else if (text[i] === '}') depth--;
Â  Â  Â  i++;
Â  Â  }
Â  Â  return i - 1;
Â  }

Â  // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­èº«ã ã‘ã‚’æŠ½å‡º
Â  function extractBlock(text, start) {
Â  Â  const openIndex = text.indexOf('{', start);
Â  Â  if (openIndex === -1) return null;
Â  Â  const endIndex = findBlockEnd(text, openIndex);
Â  Â  return text.substring(openIndex + 1, endIndex);
Â  }

Â  function addRel(map, target, type, label) {
Â  Â  if (!map.has(target)) map.set(target, { solid: new Set(), dashed: new Set() });
Â  Â  map.get(target)[type].add(label);
Â  }

Â  function removeRel(map, target, type, label) {
Â  Â  if (map.has(target)) map.get(target)[type].delete(label);
Â  }

Â  function formatType(raw) {
Â  Â  if (!raw) return "";
Â  Â  let safe = raw.trim().replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
Â  Â  return escapeGenerics(safe);
Â  }

Â  function formatArgs(raw) {
Â  Â  if (!raw) return "";
Â  Â  return escapeGenerics(raw, true);
Â  }

Â  function escapeGenerics(str, isArgList = false) {
Â  Â  let result = "";
Â  Â  let depth = 0;
Â  Â  for (let i = 0; i < str.length; i++) {
Â  Â  Â  const char = str[i];
Â  Â  Â  if (char === '<') { depth++; result += '~'; }
Â  Â  Â  else if (char === '>') { depth--; result += '~'; }
Â  Â  Â  else if (char === ',') {
Â  Â  Â  Â  if (depth > 0) result += 'ï¼Œ';Â 
Â  Â  Â  Â  else result += isArgList ? ' ' : ' ';
Â  Â  Â  } else { result += char; }
Â  Â  }
Â  Â  return result;
Â  }

Â  function removeComments(str) {
Â  Â  return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
Â  }

Â  async function renderMermaid(def) {
Â  Â  const container = document.getElementById('diagramContainer');
Â  Â  container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
Â  Â  try { await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); }Â 
Â  Â  catch(e) {Â 
Â  Â  Â  console.error(e);
Â  Â  Â  container.innerHTML = `<p style="color:red">Syntax Error</p><textarea style="width:100%;height:300px;">${def}</textarea>`;
Â  Â  }
Â  }
</script>
</body>
</html>

classDiagramã ã‘ã«ãªã£ã¦ã—ã¾ã„ã¾ã—ãŸ
