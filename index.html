<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# â†’ Mermaid Viz (Final Fix)</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
    textarea { width: 100%; height: 120px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; color: white; }
    .btn-add { background: #007bff; }
    .btn-add:hover { background: #0056b3; }
    .btn-save { background: #28a745; } 
    .btn-reset { background: #dc3545; }
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 500px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
  </style>
</head>
<body>

  <h1>C# â†’ Mermaid Visualizer (æ±ºå®šç‰ˆ)</h1>
  <p>Namespaceè§£æãƒã‚°ã‚’ä¿®æ­£ã—ã€ã‚¯ãƒ©ã‚¹å†…ã«ãƒ¡ãƒ³ãƒãƒ¼ã‚’æ ¼ç´ã™ã‚‹å½¢å¼ã§å‡ºåŠ›ã—ã¾ã™ã€‚</p>
  
  <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘"></textarea>
  
  <div class="controls">
    <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
    <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ (Save)</button>
    <button onclick="resetAll()" class="btn-reset">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
    <span id="statusMsg" style="display:none; color:#28a745; font-weight:bold; margin-left:10px;">ä¿å­˜ã—ã¾ã—ãŸï¼</span>
  </div>

  <div id="diagramContainer"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let fullSourceCode = "";

  window.addEventListener('load', async () => {
    const savedCode = localStorage.getItem('mermaid_csharp_viz_final');
    if (savedCode) {
      fullSourceCode = savedCode;
      await analyzeAndRender(fullSourceCode);
    }
  });

  window.addCode = async function() {
    const input = document.getElementById('codeInput');
    if(!input.value.trim()) return;
    fullSourceCode += "\n" + input.value;
    await analyzeAndRender(fullSourceCode);
    input.value = "";
  };

  window.saveToStorage = function() {
    localStorage.setItem('mermaid_csharp_viz_final', fullSourceCode);
    const msg = document.getElementById('statusMsg');
    msg.style.display = 'inline';
    setTimeout(() => { msg.style.display = 'none'; }, 2000);
  };

  window.resetAll = async function() {
    if(!confirm("ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
    fullSourceCode = "";
    localStorage.removeItem('mermaid_csharp_viz_final');
    document.getElementById('diagramContainer').innerHTML = "";
  };

  async function analyzeAndRender(source) {
    let cleanSource = removeComments(source);
    
    // ãƒ‡ãƒ¼ã‚¿æ§‹é€ : { namespace, className, members: [], relations: [], style: "", parent: "" }
    const parsedClasses = [];
    const processedClassNames = new Set();
    
    // Namespaceãƒãƒƒãƒ—
    const namespaceBlocks = new Map();
    namespaceBlocks.set("Global", []);

    // 1. NamespaceæŠ½å‡º (ãƒã‚°ä¿®æ­£æ¸ˆã¿)
    let cursor = 0;
    while (cursor < cleanSource.length) {
      const nsIndex = cleanSource.indexOf("namespace ", cursor);
      if (nsIndex === -1) break;

      const openBraceIndex = cleanSource.indexOf("{", nsIndex);
      const semiColonIndex = cleanSource.indexOf(";", nsIndex);
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—åˆ¤å®š
      if (semiColonIndex !== -1 && (openBraceIndex === -1 || semiColonIndex < openBraceIndex)) {
         cursor = semiColonIndex + 1; 
         continue; 
      }

      if (openBraceIndex !== -1) {
        const nsName = cleanSource.substring(nsIndex + 10, openBraceIndex).trim();
        
        // ã€é‡è¦ã€‘å‰å›ãƒã‚°ä¿®æ­£ç®‡æ‰€: openBraceIndexã‚’ãã®ã¾ã¾æ¸¡ã™
        const blockEnd = findBlockEnd(cleanSource, openBraceIndex);
        
        if (blockEnd !== -1) {
           // { ã®æ¬¡ã‹ã‚‰ } ã®å‰ã¾ã§
           const body = cleanSource.substring(openBraceIndex + 1, blockEnd);
           if (!namespaceBlocks.has(nsName)) namespaceBlocks.set(nsName, []);
           namespaceBlocks.get(nsName).push(body);

           // æŠ½å‡ºéƒ¨åˆ†ã‚’ç©ºç™½ç½®æ›
           const blockStart = nsIndex;
           const padding = " ".repeat(blockEnd - blockStart + 1);
           cleanSource = cleanSource.substring(0, blockStart) + padding + cleanSource.substring(blockEnd + 1);
           cursor = blockEnd + 1;
        } else {
           cursor = openBraceIndex + 1;
        }
      } else {
        cursor = nsIndex + 9;
      }
    }
    namespaceBlocks.get("Global").push(cleanSource);

    // 2. ã‚¯ãƒ©ã‚¹è§£æ
    for (const [nsName, blocks] of namespaceBlocks) {
      blocks.forEach(code => {
        const classRegex = /public\s+(?:static\s+)?class\s+(\w+)(?:\s*:\s*([\w, ]+))?/g;
        let match;
        while ((match = classRegex.exec(code)) !== null) {
          const className = match[1];
          if (processedClassNames.has(className)) continue;
          processedClassNames.add(className);

          const inheritanceRaw = match[2];
          const classBodyBlock = extractBlock(code, match.index + match[0].length);
          
          const classData = {
            namespace: nsName,
            className: className,
            members: [],
            relations: [], // { target, type, label }
            parent: null
          };

          // ã‚¹ã‚¿ã‚¤ãƒ«æ±ºå®š
          if (className.match(/Manager|Controller|Service/)) classData.style = "fill:#e3f2fd,stroke:#1565c0,stroke-width:2px";
          else if (className.match(/Config|Data|Model|Body|World/)) classData.style = "fill:#fff9c4,stroke:#fbc02d,stroke-width:2px";

          // ç¶™æ‰¿
          if (inheritanceRaw) {
            // æœ€åˆã®1ã¤ã ã‘è¦ªã¨ã—ã¦æ‰±ã†ï¼ˆå¤šé‡ç¶™æ‰¿ä¸å¯ã®C#å‰æï¼‰
            classData.parent = inheritanceRaw.split(',')[0].trim().split('<')[0];
          }

          // ãƒ¡ãƒ³ãƒãƒ¼è§£æ
          if (classBodyBlock) {
             parseMembers(classBodyBlock, classData);
          }
          
          parsedClasses.push(classData);
        }
      });
    }

    // 3. ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è§£æ (å…¨ã‚¯ãƒ©ã‚¹åé›†å¾Œã«å®Ÿæ–½)
    // â€»ä»Šå›ã¯ parseMembers å†…ã§ãƒ†ã‚­ã‚¹ãƒˆãƒ™ãƒ¼ã‚¹ã§ä¾å­˜ã‚’æŠ½å‡ºæ¸ˆã¿ã¨ã™ã‚‹ãŒã€
    // æ­£ç¢ºãªé‡è¤‡æ’é™¤ã®ãŸã‚ã«ã¯ã‚¯ãƒ©ã‚¹åã‚»ãƒƒãƒˆãŒå¿…è¦ã€‚
    // parseMembersé–¢æ•°å†…ã§ processedClassNames ã‚’å‚ç…§ã§ããªã„ãŸã‚ã€ã“ã“ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã™ã‚‹æ‰‹ã‚‚ã‚ã‚‹ãŒ
    // ç°¡æ˜“åŒ–ã®ãŸã‚ parseMembers ã§æŠ½å‡ºã—ãŸå€™è£œã‚’æœ‰åŠ¹ãªã‚¯ãƒ©ã‚¹ã®ã¿ã«çµã‚‹ã€‚

    // 4. Mermaidç”Ÿæˆ
    let def = "classDiagram\n";

    // Namespaceã”ã¨ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const nsGroups = new Map();
    parsedClasses.forEach(c => {
      if (!nsGroups.has(c.namespace)) nsGroups.set(c.namespace, []);
      nsGroups.get(c.namespace).push(c);
    });

    for (const [ns, classes] of nsGroups) {
      const isSub = (ns !== "Global");
      if (isSub) {
        def += `  subgraph "${ns}"\n    direction TB\n`;
      }
      
      classes.forEach(c => {
        // ã‚¯ãƒ©ã‚¹å®šç¾©é–‹å§‹ (ãƒ–ãƒ©ã‚±ãƒƒãƒˆè¨˜æ³•)
        def += `    class ${c.className} {\n`;
        c.members.forEach(m => {
          def += `      ${m}\n`;
        });
        def += `    }\n`;
        if (c.style) def += `    style ${c.className} ${c.style}\n`;
      });

      if (isSub) def += `  end\n`;
    }

    // é–¢ä¿‚æ€§ã®æç”» (subgraphã®å¤–ã«æ›¸ã)
    parsedClasses.forEach(c => {
      // ç¶™æ‰¿
      if (c.parent && processedClassNames.has(c.parent)) {
        def += `  ${c.parent} <|-- ${c.className}\n`;
      }

      // ä¾å­˜é–¢ä¿‚ã®æ•´ç†
      // Map<Target, { new: [], use: [], return: [] }>
      const relMap = new Map();
      c.relations.forEach(r => {
        if (!processedClassNames.has(r.target) || r.target === c.className) return;
        if (!relMap.has(r.target)) relMap.set(r.target, { new: new Set(), use: new Set(), return: new Set() });
        relMap.get(r.target)[r.type].add(r.label);
      });

      relMap.forEach((types, target) => {
        // é‡è¤‡é™¤å»
        types.new.forEach(l => { types.return.delete(l); types.use.delete(l); });
        
        // new (å®Ÿç·š)
        if (types.new.size > 0) {
           def += `  ${c.className} --> ${target} : new ${Array.from(types.new).join(', ')}\n`;
        }
        // return
        if (types.return.size > 0) {
           // ãƒ¡ã‚½ãƒƒãƒ‰åãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
           def += `  ${c.className} --> ${target} : ${Array.from(types.return).join(', ')}\n`;
        }
        // use (ç‚¹ç·š)
        const uses = [];
        types.use.forEach(l => uses.push(l));
        if (uses.length > 0) {
           def += `  ${c.className} ..> ${target} : ${uses.join(', ')}\n`;
        }
      });
    });

    await renderMermaid(def);
  }

  // --- è§£æãƒ­ã‚¸ãƒƒã‚¯ ---

  function parseMembers(body, classData) {
    // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
    const pRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
    let pm;
    while ((pm = pRegex.exec(body)) !== null) {
      if (pm[1].includes("class ")) continue;
      classData.members.push(`+${formatType(pm[1])} ${pm[2]}`);
    }

    // ãƒ¡ã‚½ãƒƒãƒ‰
    const mRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
    let mm;
    while ((mm = mRegex.exec(body)) !== null) {
      const retType = formatType(mm[1]);
      const mName = mm[2];
      const args = formatArgs(mm[3]);
      classData.members.push(`+${mName}(${args}) ${retType}`);

      // æˆ»ã‚Šå€¤ä¾å­˜
      const rawRet = mm[1].split('<')[0].trim().replace('[]','');
      classData.relations.push({ target: rawRet, type: 'return', label: mName });

      // å†…éƒ¨ä¾å­˜è§£æ
      const endIdx = mm.index + mm[0].length;
      const mBody = extractBlock(body, endIdx);
      if (mBody) {
        // ç°¡æ˜“çš„ã«å…¨å˜èªã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ä¾å­˜ã‚’æ¢ã™ã®ã¯é‡ã„ã®ã§ã€
        // ã“ã“ã§ã¯ã€Œæ—¢çŸ¥ã®ã‚¯ãƒ©ã‚¹ã€ãƒªã‚¹ãƒˆãŒãªã„ãŸã‚ã€
        // ã€Œå¤§æ–‡å­—å§‹ã¾ã‚Šã®å˜èªã€ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå€™è£œã¨ã—ã¦æŠ½å‡ºã™ã‚‹æˆ¦ç•¥ã‚‚ã‚ã‚‹ãŒã€
        // ç²¾åº¦ã®ãŸã‚ Regex ã§ new/static ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¢ã™
        
        // new ClassName
        const newMatches = [...mBody.matchAll(/new\s+(\w+)\s*\(/g)];
        newMatches.forEach(m => classData.relations.push({ target: m[1], type: 'new', label: mName }));

        // Static: ClassName.Method
        const statMatches = [...mBody.matchAll(/(\w+)\s*\.\w+/g)];
        statMatches.forEach(m => {
           if(m[1] !== "Math" && m[1] !== "Debug" && m[1] !== "Console") // é™¤å¤–ä¾‹
             classData.relations.push({ target: m[1], type: 'use', label: `call ${mName}` });
        });
        
        // Use: å¤‰æ•°å®£è¨€ã‚„å¼•æ•°ãªã© (ç°¡æ˜“)
        // ã“ã“ã¯å…¨ã‚¯ãƒ©ã‚¹ãƒªã‚¹ãƒˆãŒãªã„ã¨èª¤çˆ†ãŒå¤šã„ã®ã§ã€
        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚(processedClassNamesåˆ¤å®šæ™‚)ã«å¼¾ã‹ã‚Œã‚‹ã“ã¨ã‚’å‰æã«
        // new/staticä»¥å¤–ã®å‹ã£ã½ã„ã‚‚ã®ã‚’æ‹¾ã†ã®ã¯é›£ã—ã„ã€‚
        // ãªã®ã§ã€ä»Šå›ã¯ã€Œnewã€ã¨ã€Œstatic callã€ã‚’ç¢ºå®Ÿã«æ‹¾ã†æ–¹é‡ã«ã™ã‚‹ã€‚
      }
    }
  }

  // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼ ---

  function findBlockEnd(text, openIndex) {
    let depth = 1;
    let i = openIndex + 1;
    while (i < text.length && depth > 0) {
      if (text[i] === '{') depth++;
      else if (text[i] === '}') depth--;
      i++;
    }
    return i - 1;
  }

  function extractBlock(text, start) {
    const openIndex = text.indexOf('{', start);
    if (openIndex === -1) return null;
    const endIndex = findBlockEnd(text, openIndex);
    return text.substring(openIndex + 1, endIndex);
  }

  function formatType(raw) {
    let safe = raw.trim().replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
    return escapeGenerics(safe);
  }
  function formatArgs(raw) { return escapeGenerics(raw, true); }

  function escapeGenerics(str, isArgList = false) {
  let res = "", depth = 0;
  for (let i = 0; i < str.length; i++) {
    const c = str[i];
    if (c === '<') {
      depth++; 
      res += '~';
    }
    else if (c === '>') {
      depth--;
      res += '~';
    }
    else if (c === ',') {
      res += (depth > 0 ? 'ï¼Œ' : (isArgList ? ',' : ' '));
    }
    else res += c;
  }
  return res;
}

  function removeComments(str) {
    return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
  }

  async function renderMermaid(def) {
    const container = document.getElementById('diagramContainer');
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
    try { await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); }
    catch(e) { 
        console.error(e); 
        container.innerHTML = `<p style="color:red">Error</p><textarea style="width:100%;height:300px">${def}</textarea>`; 
    }
  }
</script>
</body>
</html>
