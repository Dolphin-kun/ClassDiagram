<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# → Mermaid クラス図 Visualizer（修正版）</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", Tahoma, sans-serif; padding: 20px; background: #f4f4f9; color: #333; }
    h1 { font-size: 1.4rem; }
    textarea { width: 100%; height: 150px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; }
    button { padding: 8px 16px; margin: 10px 5px 10px 0; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; }
    button.reset { background: #dc3545; }
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 200px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
    #hiddenCodes { display:none; }
  </style>
</head>
<body>

  <h1>C# → Mermaid クラス図（特殊文字対応版）</h1>
  <textarea id="codeInput" placeholder="// public class ... を含むコードを貼り付け"></textarea>
  <div>
    <button onclick="processAndAdd()">解析して追加</button>
    <button onclick="resetDiagram()" class="reset">リセット</button>
  </div>
  
  <div id="diagramContainer"></div>
  <div id="hiddenCodes"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let currentGraphDefinition = "classDiagram\n";
  let knownClasses = new Set(); // 登録済みクラスを管理

  window.processAndAdd = async function() {
    const input = document.getElementById('codeInput');
    const code = input.value;
    if(!code.trim()) return;

    document.getElementById('hiddenCodes').innerText += "\n" + code;
    let newDef = "";

    // --- 1. クラス定義の抽出 ---
    // ジェネリクス class Name<T> に対応するため < も許容するが、IDには使わない
    const classMatches = [...code.matchAll(/public\s+(?:static\s+)?class\s+([\w<>]+)/g)];
    
    classMatches.forEach(m => {
      const rawName = m[1]; 
      const safeName = sanitizeId(rawName); // List<T> -> List_T_ (ID用)
      
      if(!knownClasses.has(safeName)) {
        knownClasses.add(safeName);
        // IDは安全な文字、ラベルに元の名前を表示したい場合は `class ID["Label"]` 構文を使う
        // 今回はシンプルに ID を class 定義として追加
        if(!currentGraphDefinition.includes(`class ${safeName}`)) {
          newDef += `  class ${safeName}\n`;
        }
      }
    });

    // --- 2. メソッド & 関連の抽出 ---
    const methodMatches = [...code.matchAll(/public\s+(?:static\s+)?([\w<>\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g)];

    methodMatches.forEach(m => {
      let returnType = m[1];
      const methodName = m[2];
      let args = m[3];
      
      const ownerRaw = findOwnerClass(code, m.index);
      if(!ownerRaw) return;

      const ownerId = sanitizeId(ownerRaw);

      // Mermaid表示用に < > を ~ に置換 (Mermaidのジェネリクス表記)
      const displayRet = returnType.replace(/</g, '~').replace(/>/g, '~');
      const displayArgs = args.replace(/</g, '~').replace(/>/g, '~').replace(/,/g, ' ');

      // メソッド定義追加
      newDef += `  ${ownerId} : +${methodName}(${displayArgs}) ${displayRet}\n`;

      // --- 3. 関連線 (-->) の描画 ---
      // 戻り値の型から純粋なクラス名を取り出す (List<Player> -> Player)
      // 単純化: 英数字の塊のうち、登録済みクラスと一致するものがあれば線を引く
      
      // 戻り値に含まれる単語を抽出
      const possibleTypes = returnType.match(/\w+/g); 
      if (possibleTypes) {
        possibleTypes.forEach(t => {
          // 自分自身への参照でなく、かつ「今回のコードにある」or「過去に追加された」クラスなら
          if (t !== ownerRaw && (knownClasses.has(t) || classMatches.some(cm => sanitizeId(cm[1]) === t))) {
             // 重複線のチェックは省略（Mermaidがレンダリング時にある程度よしなにしてくれるため）
             newDef += `  ${ownerId} --> ${t} : returns\n`;
          }
        });
      }
    });

    currentGraphDefinition += newDef;
    await renderDiagram();
    input.value = "";
  };

  window.resetDiagram = async function() {
    currentGraphDefinition = "classDiagram\n";
    knownClasses.clear();
    document.getElementById('hiddenCodes').innerText = "";
    await renderDiagram();
  };

  async function renderDiagram() {
    const container = document.getElementById('diagramContainer');
    // SVG再生成のために一旦HTMLをリセット
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${currentGraphDefinition}</pre>`;
    
    try {
      await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] });
    } catch (e) {
      console.error("Mermaid Syntax Error:", e);
      container.innerHTML += `<p style="color:red">Syntax Error: ${e.message}</p><pre>${currentGraphDefinition}</pre>`;
    }
  }

  // IDとして使える安全な文字列に変換 (List<T> -> List_T)
  function sanitizeId(str) {
    // < > [ ] を _ に置換し、余分な記号を消す
    return str.split('<')[0].replace(/[^\w]/g, '_');
  }

  function findOwnerClass(code, index) {
    const before = code.substring(0, index);
    const matches = [...before.matchAll(/public\s+(?:static\s+)?class\s+([\w<>]+)/g)];
    const match = matches.pop();
    return match ? match[1] : null;
  }
</script>
</body>
</html>
