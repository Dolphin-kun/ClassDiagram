<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# → Mermaid Visualizer (Robust Fix)</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
    textarea { width: 100%; height: 150px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; }
    button { padding: 8px 16px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 4px; font-weight: bold; }
    button:hover { background: #0056b3; }
    button.reset { background: #dc3545; }
    .legend { font-size: 0.85rem; margin-left: auto; color: #555; }
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 400px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
  </style>
</head>
<body>

  <h1>C# → Mermaid Visualizer (Syntax Error Fixed)</h1>
  <p>Dictionary&lt;K,V&gt; やラムダ式プロパティ (=&gt;) に対応しました。</p>

  <textarea id="codeInput" placeholder="// C#コードを貼り付け"></textarea>
  
  <div class="controls">
    <button onclick="addCode()">解析して追加</button>
    <button onclick="resetAll()" class="reset">全リセット</button>
    <span class="legend">Generics types are safe now.</span>
  </div>

  <div id="diagramContainer"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let fullSourceCode = "";

  window.addCode = async function() {
    const input = document.getElementById('codeInput');
    if(!input.value.trim()) return;
    fullSourceCode += "\n" + input.value;
    await analyzeAndRender(fullSourceCode);
    input.value = "";
  };

  window.resetAll = async function() {
    fullSourceCode = "";
    document.getElementById('diagramContainer').innerHTML = "";
  };

  async function analyzeAndRender(source) {
    const cleanSource = removeComments(source);
    
    // クラス定義の抽出
    const classes = new Set();
    const classDefRegex = /public\s+(?:static\s+)?class\s+(\w+)/g;
    let match;
    while ((match = classDefRegex.exec(cleanSource)) !== null) {
      classes.add(match[1]);
    }

    let mermaidDef = "classDiagram\n";
    let linkStyles = ""; 
    let linkCounter = 0;

    // クラススタイル定義
    classes.forEach(cls => {
      mermaidDef += `  class ${cls}\n`;
      if (cls.match(/Manager|Controller|Service/)) mermaidDef += `  style ${cls} fill:#e3f2fd,stroke:#1565c0\n`;
      else if (cls.match(/Config|Data|Model|Body|World/)) mermaidDef += `  style ${cls} fill:#fff9c4,stroke:#fbc02d\n`;
    });

    const classBlocks = extractClassBlocks(cleanSource);

    classBlocks.forEach(block => {
      const owner = block.className;
      if (!classes.has(owner)) return;

      // --- A. プロパティ解析 (強化版) ---
      // 対応: public Type Name { get; set; }  AND  public Type Name => ...
      // Type部分に < > , [ ] スペース を許可
      const propRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
      let pMatch;
      while ((pMatch = propRegex.exec(block.body)) !== null) {
        // キーワード "class" が混ざる誤検知を防ぐ
        if (pMatch[1].includes("class ")) continue; 

        const pType = safeType(pMatch[1]);
        const pName = pMatch[2];
        mermaidDef += `  ${owner} : +${pType} ${pName}\n`;
      }

      // --- B. メソッド解析 (強化版) ---
      const methodRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
      let mMatch;
      const dependencies = new Map();

      while ((mMatch = methodRegex.exec(block.body)) !== null) {
        const [_, retRaw, mName, argsRaw] = mMatch;
        
        // 戻り値や引数の型をサニタイズ (Dictionary<int, int> -> Dictionary~int_ int~)
        const dRet = safeType(retRaw);
        const dArgs = safeArgs(argsRaw); // カンマ区切りの引数を安全に処理
        
        mermaidDef += `  ${owner} : +${mName}(${dArgs}) ${dRet}\n`;

        // 戻り値の依存関係
        const rawRetClass = retRaw.split('<')[0].trim().replace('[]','');
        if (classes.has(rawRetClass) && rawRetClass !== owner) {
           addDep(dependencies, rawRetClass, 'return', 'returns');
        }

        // メソッド内部解析
        const endIdx = mMatch.index + mMatch[0].length;
        const body = extractBlock(block.body, endIdx);
        
        if (body) {
           classes.forEach(target => {
             if (target === owner) return;

             // new Target(...)
             const newRegex = new RegExp(`new\\s+${target}\\s*\\(`);
             if (newRegex.test(body)) {
               addDep(dependencies, target, 'new', mName);
             }
             // Static call: Target.Method
             const staticRegex = new RegExp(`\\b${target}\\s*\\.\\w+`);
             if (staticRegex.test(body)) {
               addDep(dependencies, target, 'static', mName);
             }
             // 通常使用
             const useRegex = new RegExp(`\\b${target}\\b`);
             if (useRegex.test(body)) {
               addDep(dependencies, target, 'use', mName);
             }
           });
        }
      }

      // 依存関係描画
      dependencies.forEach((info, target) => {
        let linkStr = "";
        let color = "";
        const labelText = Array.from(info.labels).join(', ');

        if (info.types.has('new')) {
          linkStr = `  ${owner} --> ${target} : new ${labelText}\n`;
          color = "#e53935"; // Red
        } else if (info.types.has('static')) {
          linkStr = `  ${owner} ..> ${target} : call ${labelText}\n`;
          color = "#43a047"; // Green
        } else {
          linkStr = `  ${owner} ..> ${target} : ${labelText}\n`;
          color = ""; 
        }

        mermaidDef += linkStr;
        if (color) {
          linkStyles += `  linkStyle ${linkCounter} stroke:${color},stroke-width:2px,color:${color};\n`;
        }
        linkCounter++;
      });
    });

    mermaidDef += linkStyles;

    // エラーハンドリング付き描画
    await renderMermaid(mermaidDef);
  }

  // --- ヘルパー関数群 ---

  function addDep(map, target, type, label) {
    if (!map.has(target)) {
      map.set(target, { types: new Set(), labels: new Set() });
    }
    const entry = map.get(target);
    entry.types.add(type);
    if (label !== 'returns') entry.labels.add(label);
  }

  // 型名のサニタイズ: Dictionary<int, PhysicsWorld> -> Dictionary~int_PhysicsWorld~
  function safeType(t) {
    if(!t) return "";
    let safe = t.trim();
    // 不要な修飾子削除
    safe = safe.replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
    // < > を ~ に置換 (Mermaidジェネリクス)
    safe = safe.replace(/</g, '~').replace(/>/g, '~');
    // 型の中のカンマはMermaidで誤作動の原因になるため、アンダースコアかスペースに置換
    // ただし、~で囲まれた内部だけ置換したいが、簡易的に全体置換でも表示は崩れない
    // ここでは見た目を優先してカンマをそのまま許容せず置換する
    safe = safe.replace(/,/g, ' '); 
    return safe;
  }

  // 引数リストのサニタイズ: (int a, Action<T> b) -> int a, Action~T~ b
  function safeArgs(argsRaw) {
    if(!argsRaw) return "";
    // まずジェネリクスの < > を ~ に
    let s = argsRaw.replace(/</g, '~').replace(/>/g, '~');
    // 引数区切りのカンマは維持したいが、Mermaidは()内でカンマを使うとエラーになる場合がある
    // そのため、カンマをスペースに置換するのが安全
    s = s.replace(/,/g, ' '); 
    return s;
  }

  function extractClassBlocks(src) {
    const blocks = [];
    const regex = /public\s+(?:static\s+)?class\s+(\w+)/g;
    let match;
    while((match = regex.exec(src)) !== null) {
      const body = extractBlock(src, match.index + match[0].length);
      if(body) blocks.push({ className: match[1], body });
    }
    return blocks;
  }
  
  function extractBlock(text, start) {
    let open = text.indexOf('{', start);
    if(open === -1) return null;
    let d = 1, i = open + 1;
    while(i < text.length && d > 0) {
      if(text[i] === '{') d++;
      else if(text[i] === '}') d--;
      i++;
    }
    return text.substring(open + 1, i - 1);
  }

  function removeComments(str) {
    return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
  }

  async function renderMermaid(def) {
    const container = document.getElementById('diagramContainer');
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
    try { 
      await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); 
    } catch(e) {
      console.error(e);
      // エラー時は原因箇所のテキストを表示
      container.innerHTML = `<p style="color:red; font-weight:bold;">Syntax Error Fix Failed.</p>
                             <p>Mermaid cannot parse:</p>
                             <textarea style="width:100%;height:300px;">${def}</textarea>`;
    }
  }
</script>
</body>
</html>
