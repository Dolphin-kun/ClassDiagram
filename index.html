<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# â†’ Mermaid Viz (Fixed Namespace)</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
    textarea { width: 100%; height: 120px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
    
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; color: white; }
    .btn-add { background: #007bff; }
    .btn-add:hover { background: #0056b3; }
    .btn-save { background: #28a745; } 
    .btn-save:hover { background: #218838; }
    .btn-reset { background: #dc3545; }
    .btn-reset:hover { background: #c82333; }

    .status-msg { font-size: 0.9rem; color: #28a745; display: none; margin-left: 10px; font-weight: bold;}
    
    .legend { font-size: 0.85rem; margin-left: auto; color: #555; display: flex; gap: 10px; }
    .legend span { display: flex; align-items: center; gap: 4px; }
    
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 500px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
  </style>
</head>
<body>

  <h1>C# â†’ Mermaid Visualizer (Namespaceä¿®æ­£ç‰ˆ)</h1>
  <p>Namespaceã®è§£æãƒ­ã‚¸ãƒƒã‚¯ã‚’ä¿®æ­£ã—ã€ã‚¯ãƒ©ã‚¹ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚</p>
  
  <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘"></textarea>
  
  <div class="controls">
    <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
    <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ (Save)</button>
    <button onclick="resetAll()" class="btn-reset">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
    <span id="statusMsg" class="status-msg">ä¿å­˜ã—ã¾ã—ãŸï¼</span>
    
    <div class="legend">
      <span><b>â”â”â–·</b> new (ç”Ÿæˆ)</span>
      <span><b>- - â–·</b> use (ä¾å­˜)</span>
      <span><b>â”€â”€â–·</b> ç¶™æ‰¿</span>
    </div>
  </div>

  <div id="diagramContainer"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let fullSourceCode = "";

  window.addEventListener('load', async () => {
    const savedCode = localStorage.getItem('mermaid_csharp_viz_ns');
    if (savedCode) {
      fullSourceCode = savedCode;
      await analyzeAndRender(fullSourceCode);
    }
  });

  window.addCode = async function() {
    const input = document.getElementById('codeInput');
    if(!input.value.trim()) return;
    fullSourceCode += "\n" + input.value;
    await analyzeAndRender(fullSourceCode);
    input.value = "";
  };

  window.saveToStorage = function() {
    localStorage.setItem('mermaid_csharp_viz_ns', fullSourceCode);
    const msg = document.getElementById('statusMsg');
    msg.style.display = 'inline';
    setTimeout(() => { msg.style.display = 'none'; }, 2000);
  };

  window.resetAll = async function() {
    if(!confirm("ç¾åœ¨ã®å›³ã¨ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) return;
    fullSourceCode = "";
    localStorage.removeItem('mermaid_csharp_viz_ns');
    document.getElementById('diagramContainer').innerHTML = "";
  };

  async function analyzeAndRender(source) {
    // ã‚³ãƒ¡ãƒ³ãƒˆå‰Šé™¤
    let cleanSource = removeComments(source);
    
    const processedClasses = new Set();
    const namespaceMap = new Map();
    namespaceMap.set("Global", []); 

    // --- NamespaceæŠ½å‡ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆä¿®æ­£ç‰ˆï¼‰ ---
    let cursor = 0;
    while (cursor < cleanSource.length) {
      const nsIndex = cleanSource.indexOf("namespace ", cursor);
      if (nsIndex === -1) break; 

      const openBraceIndex = cleanSource.indexOf("{", nsIndex);
      const semiColonIndex = cleanSource.indexOf(";", nsIndex);
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ— namespace X; ã®ç°¡æ˜“åˆ¤å®š
      if (semiColonIndex !== -1 && (openBraceIndex === -1 || semiColonIndex < openBraceIndex)) {
         cursor = semiColonIndex + 1; 
         continue;
      }

      if (openBraceIndex !== -1) {
        // åå‰å–å¾—
        const nsName = cleanSource.substring(nsIndex + 10, openBraceIndex).trim();
        
        // ã€ä¿®æ­£ç‚¹ã€‘findBlockEndã‚’ä½¿ã£ã¦æ­£ç¢ºãªç¯„å›²ã‚’å–å¾—
        const blockEnd = findBlockEnd(cleanSource, openBraceIndex);
        
        if (blockEnd !== -1) {
           // { ã¨ } ã®é–“ã®æ–‡å­—åˆ—ã‚’å–å¾—ï¼ˆã“ã‚ŒãŒNamespaceã®ä¸­èº«ï¼‰
           const body = cleanSource.substring(openBraceIndex + 1, blockEnd);
           
           if (!namespaceMap.has(nsName)) namespaceMap.set(nsName, []);
           namespaceMap.get(nsName).push(body);

           // æŠ½å‡ºã—ãŸéƒ¨åˆ†ã‚’å…ƒæ–‡å­—åˆ—ã‹ã‚‰æ¶ˆã™ï¼ˆç©ºç™½ã§åŸ‹ã‚ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãšã‚Œã‚’é˜²ãï¼‰
           const blockStart = nsIndex; 
           const padding = " ".repeat(blockEnd - blockStart + 1);
           
           const before = cleanSource.substring(0, blockStart);
           const after = cleanSource.substring(blockEnd + 1);
           cleanSource = before + padding + after;
           
           cursor = blockEnd + 1;
        } else {
           // é–‰ã˜æ‹¬å¼§ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆãªã©
           cursor = openBraceIndex + 1;
        }
      } else {
        cursor = nsIndex + 9;
      }
    }

    // æ®‹ã‚Šã¯Global
    namespaceMap.get("Global").push(cleanSource);

    let mermaidDef = "classDiagram\n";
    const allClassBlocks = [];

    // --- å„Namespaceè§£æ ---
    for (const [nsName, codeBlocks] of namespaceMap) {
      if (codeBlocks.join("").trim() === "") continue;

      let nsDef = "";
      
      codeBlocks.forEach(code => {
        const regex = /public\s+(?:static\s+)?class\s+(\w+)(?:\s*:\s*([\w, ]+))?/g;
        let match;
        while ((match = regex.exec(code)) !== null) {
          const className = match[1];
          const inheritanceRaw = match[2];

          if (processedClasses.has(className)) continue;
          processedClasses.add(className);

          nsDef += `    class ${className}\n`;
          
          if (className.match(/Manager|Controller|Service/)) nsDef += `    style ${className} fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n`;
          else if (className.match(/Config|Data|Model|Body|World/)) nsDef += `    style ${className} fill:#fff9c4,stroke:#fbc02d,stroke-width:2px\n`;

          if (inheritanceRaw) {
             const parents = inheritanceRaw.split(',').map(p => p.trim().split('<')[0]);
             parents.forEach(p => {
               allClassBlocks.push({ type:'inheritance', child: className, parent: p });
             });
          }

          const body = extractBlock(code, match.index + match[0].length);
          if (body) {
            allClassBlocks.push({ type:'class', className, body });
          }
        }
      });

      if (nsDef.trim() !== "") {
        if (nsName !== "Global") {
          mermaidDef += `  subgraph "${nsName}"\n`;
          mermaidDef += `    direction TB\n`;
          mermaidDef += nsDef;
          mermaidDef += `  end\n`;
        } else {
          mermaidDef += nsDef;
        }
      }
    }

    // --- è©³ç´°è§£æ ---
    allClassBlocks.forEach(item => {
      if (item.type === 'inheritance') {
         if (processedClasses.has(item.parent)) {
            mermaidDef += `  ${item.parent} <|-- ${item.child}\n`;
         }
         return;
      }

      const owner = item.className;
      const body = item.body;

      // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      const propRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
      let pMatch;
      while ((pMatch = propRegex.exec(body)) !== null) {
        if (pMatch[1].includes("class ")) continue; 
        mermaidDef += `  ${owner} : +${formatType(pMatch[1])} ${pMatch[2]}\n`;
      }

      // ãƒ¡ã‚½ãƒƒãƒ‰
      const methodRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
      let mMatch;
      const relations = new Map(); 

      while ((mMatch = methodRegex.exec(body)) !== null) {
        const [_, retRaw, mName, argsRaw] = mMatch;
        const dRet = formatType(retRaw);
        const dArgs = formatArgs(argsRaw);
        
        mermaidDef += `  ${owner} : +${mName}(${dArgs}) ${dRet}\n`;

        // æˆ»ã‚Šå€¤
        const rawRetClass = retRaw.split('<')[0].trim().replace('[]','');
        if (processedClasses.has(rawRetClass) && rawRetClass !== owner) {
           addRel(relations, rawRetClass, 'solid', mName);
        }

        // å†…éƒ¨è§£æ
        const endIdx = mMatch.index + mMatch[0].length;
        const mBody = extractBlock(body, endIdx);
        
        if (mBody) {
           processedClasses.forEach(target => {
             if (target === owner) return;
             
             if (new RegExp(`new\\s+${target}\\s*\\(`).test(mBody)) {
               addRel(relations, target, 'solid', `new ${mName}`);
               removeRel(relations, target, 'solid', mName);
             }
             else if (new RegExp(`\\b${target}\\s*\\.\\w+`).test(mBody)) {
               addRel(relations, target, 'dashed', `call ${mName}`);
             }
             else if (new RegExp(`\\b${target}\\b`).test(mBody)) {
               addRel(relations, target, 'dashed', mName);
             }
           });
        }
      }

      // æç”»
      relations.forEach((types, target) => {
        if (types.solid.size > 0) {
          mermaidDef += `  ${owner} --> ${target} : ${Array.from(types.solid).join(', ')}\n`;
        }
        
        types.dashed.forEach(label => {
            const rawLabel = label.replace('call ', '').replace('new ', '');
            let isDuplicated = false;
            types.solid.forEach(s => { if(s.includes(rawLabel)) isDuplicated = true; });
            if(isDuplicated) types.dashed.delete(label);
        });

        if (types.dashed.size > 0) {
          mermaidDef += `  ${owner} ..> ${target} : ${Array.from(types.dashed).join(', ')}\n`;
        }
      });
    });

    await renderMermaid(mermaidDef);
  }

  // --- Helpers ---

  function findBlockEnd(text, openIndex) {
    let depth = 1;
    let i = openIndex + 1;
    while (i < text.length && depth > 0) {
      if (text[i] === '{') depth++;
      else if (text[i] === '}') depth--;
      i++;
    }
    return i - 1;
  }

  function extractBlock(text, start) {
    const openIndex = text.indexOf('{', start);
    if (openIndex === -1) return null;
    const endIndex = findBlockEnd(text, openIndex);
    return text.substring(openIndex + 1, endIndex);
  }

  function addRel(map, target, type, label) {
    if (!map.has(target)) map.set(target, { solid: new Set(), dashed: new Set() });
    map.get(target)[type].add(label);
  }

  function removeRel(map, target, type, label) {
    if (map.has(target)) map.get(target)[type].delete(label);
  }

  function formatType(raw) {
    if (!raw) return "";
    let safe = raw.trim().replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
    return escapeGenerics(safe);
  }

  function formatArgs(raw) {
    if (!raw) return "";
    return escapeGenerics(raw, true);
  }

  function escapeGenerics(str, isArgList = false) {
    let result = "";
    let depth = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === '<') { depth++; result += '~'; }
      else if (char === '>') { depth--; result += '~'; }
      else if (char === ',') {
        if (depth > 0) result += 'ï¼Œ'; 
        else result += isArgList ? ' ' : ' ';
      } else { result += char; }
    }
    return result;
  }

  function removeComments(str) {
    return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
  }

  async function renderMermaid(def) {
    const container = document.getElementById('diagramContainer');
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
    try { await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); } 
    catch(e) { 
      console.error(e);
      container.innerHTML = `<p style="color:red">Syntax Error</p><textarea style="width:100%;height:300px;">${def}</textarea>`;
    }
  }
</script>
</body>
</html>
