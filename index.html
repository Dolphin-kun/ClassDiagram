<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# â†’ Mermaid Visualizer (Save & Arrow Fix)</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
    textarea { width: 100%; height: 120px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
    
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    /* ãƒœã‚¿ãƒ³ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
    button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; color: white; }
    .btn-add { background: #007bff; }
    .btn-add:hover { background: #0056b3; }
    .btn-save { background: #28a745; } /* ç·‘è‰² */
    .btn-save:hover { background: #218838; }
    .btn-reset { background: #dc3545; }
    .btn-reset:hover { background: #c82333; }

    .status-msg { font-size: 0.9rem; color: #28a745; display: none; margin-left: 10px; font-weight: bold;}
    
    .legend { font-size: 0.85rem; margin-left: auto; color: #555; display: flex; gap: 10px; }
    .legend span { display: flex; align-items: center; gap: 4px; }
    
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 400px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
  </style>
</head>
<body>

  <h1>C# â†’ Mermaid Visualizer (ä¿å­˜æ©Ÿèƒ½ä»˜ã)</h1>
  <p>ã‚³ãƒ¼ãƒ‰è§£æã«åŠ ãˆã€ç¶™æ‰¿é–¢ä¿‚ã®æ¤œçŸ¥ã¨ãƒ‡ãƒ¼ã‚¿ã®ãƒ–ãƒ©ã‚¦ã‚¶ä¿å­˜ã«å¯¾å¿œã—ã¾ã—ãŸã€‚</p>
  
  <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘"></textarea>
  
  <div class="controls">
    <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
    <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ (Save)</button>
    <button onclick="resetAll()" class="btn-reset">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
    <span id="statusMsg" class="status-msg">ä¿å­˜ã—ã¾ã—ãŸï¼</span>
    
    <div class="legend">
      <span><b>â”â”â–·</b> new/return (å®Ÿç·š)</span>
      <span><b>- - â–·</b> use (ç‚¹ç·š)</span>
      <span><b>â”€â”€â–·</b> ç¶™æ‰¿</span>
    </div>
  </div>

  <div id="diagramContainer"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let fullSourceCode = "";

  // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ä¿å­˜ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒ
  window.addEventListener('load', async () => {
    const savedCode = localStorage.getItem('mermaid_csharp_viz');
    if (savedCode) {
      fullSourceCode = savedCode;
      await analyzeAndRender(fullSourceCode);
    }
  });

  window.addCode = async function() {
    const input = document.getElementById('codeInput');
    if(!input.value.trim()) return;
    fullSourceCode += "\n" + input.value;
    await analyzeAndRender(fullSourceCode);
    input.value = "";
  };

  // ä¿æŒï¼ˆä¿å­˜ï¼‰æ©Ÿèƒ½
  window.saveToStorage = function() {
    localStorage.setItem('mermaid_csharp_viz', fullSourceCode);
    const msg = document.getElementById('statusMsg');
    msg.style.display = 'inline';
    setTimeout(() => { msg.style.display = 'none'; }, 2000);
  };

  window.resetAll = async function() {
    if(!confirm("ç¾åœ¨ã®å›³ã¨ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) return;
    fullSourceCode = "";
    localStorage.removeItem('mermaid_csharp_viz');
    document.getElementById('diagramContainer').innerHTML = "";
  };

  async function analyzeAndRender(source) {
    const cleanSource = removeComments(source);
    const classes = new Set();
    const classDefRegex = /public\s+(?:static\s+)?class\s+(\w+)/g;
    let match;
    while ((match = classDefRegex.exec(cleanSource)) !== null) {
      classes.add(match[1]);
    }

    let mermaidDef = "classDiagram\n";

    // ã‚¯ãƒ©ã‚¹å®šç¾© & ã‚¹ã‚¿ã‚¤ãƒ«
    classes.forEach(cls => {
      mermaidDef += `  class ${cls}\n`;
      if (cls.match(/Manager|Controller|Service/)) mermaidDef += `  style ${cls} fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n`;
      else if (cls.match(/Config|Data|Model|Body|World/)) mermaidDef += `  style ${cls} fill:#fff9c4,stroke:#fbc02d,stroke-width:2px\n`;
    });

    // --- ç¶™æ‰¿é–¢ä¿‚ã®è§£æ (class A : B) ---
    // Regex: class Child : Parent
    const inheritanceRegex = /public\s+(?:static\s+)?class\s+(\w+)\s*:\s*([\w, ]+)/g;
    let iMatch;
    while ((iMatch = inheritanceRegex.exec(cleanSource)) !== null) {
      const child = iMatch[1];
      const parentsRaw = iMatch[2];
      const parents = parentsRaw.split(',').map(p => p.trim());
      
      parents.forEach(parent => {
        // ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ã‚„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’é™¤å¤–ã—ã€æ—¢çŸ¥ã®ã‚¯ãƒ©ã‚¹ã®ã¿ç¶™æ‰¿ç·šã‚’å¼•ã
        // ã‚‚ã—ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚‚å«ã‚ãŸã„å ´åˆã¯ã“ã“ã‚’èª¿æ•´
        const safeParent = parent.split('<')[0]; 
        if (classes.has(safeParent)) {
          mermaidDef += `  ${safeParent} <|-- ${child}\n`;
        }
      });
    }

    const classBlocks = extractClassBlocks(cleanSource);

    classBlocks.forEach(block => {
      const owner = block.className;
      if (!classes.has(owner)) return;

      // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      const propRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
      let pMatch;
      while ((pMatch = propRegex.exec(block.body)) !== null) {
        if (pMatch[1].includes("class ")) continue; 
        mermaidDef += `  ${owner} : +${formatType(pMatch[1])} ${pMatch[2]}\n`;
      }

      // ãƒ¡ã‚½ãƒƒãƒ‰è§£æ & ä¾å­˜ãƒãƒƒãƒ—æ§‹ç¯‰
      const methodRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
      let mMatch;
      
      // Arrow Typeã”ã¨ã®ãƒ©ãƒ™ãƒ«Setã‚’ç®¡ç†
      // solid: --> (new, return)
      // dashed: ..> (use, static)
      const relations = new Map(); // Key: TargetClass, Value: { solid: Set, dashed: Set }

      while ((mMatch = methodRegex.exec(block.body)) !== null) {
        const [_, retRaw, mName, argsRaw] = mMatch;
        const dRet = formatType(retRaw);
        const dArgs = formatArgs(argsRaw);
        
        mermaidDef += `  ${owner} : +${mName}(${dArgs}) ${dRet}\n`;

        // æˆ»ã‚Šå€¤ -> Solid
        const rawRetClass = retRaw.split('<')[0].trim().replace('[]','');
        if (classes.has(rawRetClass) && rawRetClass !== owner) {
           addRel(relations, rawRetClass, 'solid', mName); // ãƒ¡ã‚½ãƒƒãƒ‰åã‚’ãƒ©ãƒ™ãƒ«ã«ã™ã‚‹
        }

        // å†…éƒ¨è§£æ
        const endIdx = mMatch.index + mMatch[0].length;
        const body = extractBlock(block.body, endIdx);
        
        if (body) {
           classes.forEach(target => {
             if (target === owner) return;
             
             // new -> Solid (prefix: new)
             if (new RegExp(`new\\s+${target}\\s*\\(`).test(body)) {
               addRel(relations, target, 'solid', `new ${mName}`);
               // é‡è¤‡å›é¿: newãŒã‚ã‚‹ãªã‚‰å˜ãªã‚‹æˆ»ã‚Šå€¤ã¨ã—ã¦ã®è¡¨ç¤ºã¯æ¶ˆã™
               removeRel(relations, target, 'solid', mName);
             }
             // Static call -> Dashed (prefix: call)
             else if (new RegExp(`\\b${target}\\s*\\.\\w+`).test(body)) {
               addRel(relations, target, 'dashed', `call ${mName}`);
             }
             // Use -> Dashed
             else if (new RegExp(`\\b${target}\\b`).test(body)) {
               addRel(relations, target, 'dashed', mName);
             }
           });
        }
      }

      // æç”»
      relations.forEach((types, target) => {
        // å®Ÿç·š (-->) : new, return
        if (types.solid.size > 0) {
          mermaidDef += `  ${owner} --> ${target} : ${Array.from(types.solid).join(', ')}\n`;
        }
        
        // ç‚¹ç·š (..>) : use, static
        // å®Ÿç·šã§æ—¢ã«è¨€åŠã•ã‚Œã¦ã„ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒç‚¹ç·šã«å«ã¾ã‚Œã‚‹å ´åˆã¯å‰Šé™¤ã™ã‚‹ï¼ˆé‡è¤‡æ•´ç†ï¼‰
        types.dashed.forEach(label => {
            // "new Method" ã¨ "Method" ã®ã‚ˆã†ãªé‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
            const rawLabel = label.replace('call ', '').replace('new ', '');
            let isDuplicated = false;
            types.solid.forEach(s => {
                if(s.includes(rawLabel)) isDuplicated = true;
            });
            if(isDuplicated) types.dashed.delete(label);
        });

        if (types.dashed.size > 0) {
          mermaidDef += `  ${owner} ..> ${target} : ${Array.from(types.dashed).join(', ')}\n`;
        }
      });
    });

    await renderMermaid(mermaidDef);
  }

  function addRel(map, target, type, label) {
    if (!map.has(target)) map.set(target, { solid: new Set(), dashed: new Set() });
    map.get(target)[type].add(label);
  }

  function removeRel(map, target, type, label) {
    if (map.has(target)) map.get(target)[type].delete(label);
  }

  function formatType(raw) {
    if (!raw) return "";
    let safe = raw.trim().replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
    return escapeGenerics(safe);
  }

  function formatArgs(raw) {
    if (!raw) return "";
    return escapeGenerics(raw, true);
  }

  function escapeGenerics(str, isArgList = false) {
    let result = "";
    let depth = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === '<') { depth++; result += '~'; }
      else if (char === '>') { depth--; result += '~'; }
      else if (char === ',') {
        if (depth > 0) result += 'ï¼Œ'; 
        else result += isArgList ? ' ' : ' ';
      } else { result += char; }
    }
    return result;
  }

  function extractClassBlocks(src) {
    const blocks = [];
    const regex = /public\s+(?:static\s+)?class\s+(\w+)/g;
    let match;
    while((match = regex.exec(src)) !== null) {
      const body = extractBlock(src, match.index + match[0].length);
      if(body) blocks.push({ className: match[1], body });
    }
    return blocks;
  }
  
  function extractBlock(text, start) {
    let open = text.indexOf('{', start);
    if(open === -1) return null;
    let d = 1, i = open + 1;
    while(i < text.length && d > 0) {
      if(text[i] === '{') d++;
      else if(text[i] === '}') d--;
      i++;
    }
    return text.substring(open + 1, i - 1);
  }

  function removeComments(str) {
    return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
  }

  async function renderMermaid(def) {
    const container = document.getElementById('diagramContainer');
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
    try { await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); } 
    catch(e) { 
      console.error(e);
      container.innerHTML = `<p style="color:red">Syntax Error</p><textarea style="width:100%;height:300px;">${def}</textarea>`;
    }
  }
</script>
</body>
</html>
