<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# â†’ Mermaid Viz (Namespace & Unique)</title>
  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false });
    window.mermaid = mermaid;
  </script>
  <style>
    body { font-family: "Segoe UI", sans-serif; padding: 20px; background: #f4f6f8; color: #333; }
    textarea { width: 100%; height: 120px; padding: 10px; font-family: Consolas, monospace; border-radius: 6px; border: 1px solid #ccc; }
    
    .controls { margin: 10px 0; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    button { padding: 8px 16px; cursor: pointer; border: none; border-radius: 4px; font-weight: bold; transition: background 0.2s; color: white; }
    .btn-add { background: #007bff; }
    .btn-add:hover { background: #0056b3; }
    .btn-save { background: #28a745; } 
    .btn-save:hover { background: #218838; }
    .btn-reset { background: #dc3545; }
    .btn-reset:hover { background: #c82333; }

    .status-msg { font-size: 0.9rem; color: #28a745; display: none; margin-left: 10px; font-weight: bold;}
    
    .legend { font-size: 0.85rem; margin-left: auto; color: #555; display: flex; gap: 10px; }
    .legend span { display: flex; align-items: center; gap: 4px; }
    
    #diagramContainer { background: #fff; padding: 20px; border-radius: 8px; min-height: 500px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); overflow: auto; }
  </style>
</head>
<body>

  <h1>C# â†’ Mermaid Visualizer (Namespaceå¯¾å¿œç‰ˆ)</h1>
  <p>Namespaceã”ã¨ã®ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã¨ã€é‡è¤‡ã‚¯ãƒ©ã‚¹ã®è‡ªå‹•é™¤å¤–ã‚’è¡Œã„ã¾ã™ã€‚</p>
  
  <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’è²¼ã‚Šä»˜ã‘"></textarea>
  
  <div class="controls">
    <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
    <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ (Save)</button>
    <button onclick="resetAll()" class="btn-reset">å…¨ãƒªã‚»ãƒƒãƒˆ</button>
    <span id="statusMsg" class="status-msg">ä¿å­˜ã—ã¾ã—ãŸï¼</span>
    
    <div class="legend">
      <span><b>â”â”â–·</b> new (ç”Ÿæˆ)</span>
      <span><b>- - â–·</b> use (ä¾å­˜)</span>
      <span><b>â”€â”€â–·</b> ç¶™æ‰¿</span>
    </div>
  </div>

  <div id="diagramContainer"></div>

<script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

  let fullSourceCode = "";

  window.addEventListener('load', async () => {
    const savedCode = localStorage.getItem('mermaid_csharp_viz_ns');
    if (savedCode) {
      fullSourceCode = savedCode;
      await analyzeAndRender(fullSourceCode);
    }
  });

  window.addCode = async function() {
    const input = document.getElementById('codeInput');
    if(!input.value.trim()) return;
    fullSourceCode += "\n" + input.value;
    await analyzeAndRender(fullSourceCode);
    input.value = "";
  };

  window.saveToStorage = function() {
    localStorage.setItem('mermaid_csharp_viz_ns', fullSourceCode);
    const msg = document.getElementById('statusMsg');
    msg.style.display = 'inline';
    setTimeout(() => { msg.style.display = 'none'; }, 2000);
  };

  window.resetAll = async function() {
    if(!confirm("ç¾åœ¨ã®å›³ã¨ä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ã™ã¹ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) return;
    fullSourceCode = "";
    localStorage.removeItem('mermaid_csharp_viz_ns');
    document.getElementById('diagramContainer').innerHTML = "";
  };

  async function analyzeAndRender(source) {
    let cleanSource = removeComments(source);
    
    // ã‚¯ãƒ©ã‚¹åã®ä¸€æ„æ€§ã‚’ä¿ã¤ãŸã‚ã®Setï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
    const processedClasses = new Set();
    
    // Namespaceã”ã¨ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç®¡ç†ã™ã‚‹Map
    // key: namespaceå, value: ã‚³ãƒ¼ãƒ‰æ–‡å­—åˆ—ã®é…åˆ—
    const namespaceMap = new Map();
    namespaceMap.set("Global", []); // Namespaceå¤–ã®ã‚¯ãƒ©ã‚¹ç”¨

    // 1. ãƒ–ãƒ­ãƒƒã‚¯å½¢å¼ã®Namespaceã‚’æŠ½å‡º (namespace X { ... })
    // Regex: namespace Name { body }
    const nsBlockRegex = /namespace\s+([\w\.]+)\s*/g;
    let match;
    
    // æ–‡å­—åˆ—ã‚’èµ°æŸ»ã—ã¦Namespaceãƒ–ãƒ­ãƒƒã‚¯ã‚’åˆ‡ã‚Šå‡ºã™
    // extractBlockã‚’ä½¿ã†ãŸã‚ã€Regexãƒ«ãƒ¼ãƒ—ã§ã¯ãªãæ‰‹å‹•ã§æ¤œç´¢ä½ç½®ã‚’é€²ã‚ã‚‹
    let cursor = 0;
    while (cursor < cleanSource.length) {
      // æ¬¡ã® "namespace" ã‚’æ¢ã™
      const nsIndex = cleanSource.indexOf("namespace ", cursor);
      if (nsIndex === -1) break; // ã‚‚ã†ãªã„

      // namespaceã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã®å¾Œã® "{" ã‚’æ¢ã™
      const openBraceIndex = cleanSource.indexOf("{", nsIndex);
      const semiColonIndex = cleanSource.indexOf(";", nsIndex);
      
      // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ— (namespace X;) ã‹ ãƒ–ãƒ­ãƒƒã‚¯ (namespace X { }) ã‹åˆ¤å®š
      // { ã‚ˆã‚Šå…ˆã« ; ãŒæ¥ãŸã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ï¼ˆã‚ã‚‹ã„ã¯ { ãŒãªã„ï¼‰
      if (semiColonIndex !== -1 && (openBraceIndex === -1 || semiColonIndex < openBraceIndex)) {
         // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—: namespace X;
         // æœ¬å½“ã¯ã“ã‚Œä»¥é™ã®å…¨ã‚³ãƒ¼ãƒ‰ãŒå¯¾è±¡ã ãŒã€ç°¡æ˜“çš„ã«ã€Œã“ã“ã‹ã‚‰æœ«å°¾ã¾ã§ã€ã‚’ãã®Namespaceæ‰±ã„ã«ã™ã‚‹
         // ãŸã ã—ã€è¤‡æ•°è²¼ã‚Šä»˜ã‘ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã®å®Ÿè£…ã¯
         // ã€Œè²¼ã‚Šä»˜ã‘å˜ä½ã€ã§ç®¡ç†ã—ãªã„ã¨é›£ã—ã„ã€‚
         // ä»Šå›ã¯ç°¡æ˜“çš„ã«ã€ŒGlobalã€æ‰±ã„ã«ã™ã‚‹ã‹ã€æ­£è¦è¡¨ç¾ã§åå‰ã ã‘å–ã‚‹ã€‚
         // â€»è¤‡é›‘åŒ–å›é¿ã®ãŸã‚ã€ä»Šå›ã¯ { } ãƒ–ãƒ­ãƒƒã‚¯å½¢å¼ã‚’å„ªå…ˆã—ã¦å‡¦ç†ã—ã€ãƒãƒƒãƒã—ãªã„éƒ¨åˆ†ã¯Globalã«æ®‹ã™
         cursor = semiColonIndex + 1; 
         continue;
      }

      if (openBraceIndex !== -1) {
        // åå‰ã‚’å–å¾—
        const nsName = cleanSource.substring(nsIndex + 10, openBraceIndex).trim();
        
        // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­èº«ã‚’æŠ½å‡º
        const body = extractBlock(cleanSource, openBraceIndex + 1); // +1ä¿®æ­£: {ã®æ¬¡ã‹ã‚‰
        
        if (body) {
           if (!namespaceMap.has(nsName)) namespaceMap.set(nsName, []);
           namespaceMap.get(nsName).push(body);

           // å…ƒã®æ–‡å­—åˆ—ã‹ã‚‰ã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’é™¤å»ï¼ˆç½®æ›ï¼‰ã—ã¦Globalã«æ®‹ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
           // ãŸã ã—ä½ç½®ãŒãšã‚Œã‚‹ã®ã§ã€é™¤å»ã™ã‚‹éƒ¨åˆ†ã¯ç©ºç™½ã§åŸ‹ã‚ã‚‹ã‹ã€
           // ã€ŒæŠ½å‡ºã—ãŸã‚‚ã®ãƒªã‚¹ãƒˆã€ã ã‘ã§å‡¦ç†ã‚’é€²ã‚ã‚‹ã€‚
           // ã“ã“ã§ã¯ã€ŒnamespaceMapã€ã«å…¥ã‚ŒãŸä¸Šã§ã€Globalè§£æç”¨ã«å…ƒã®æ–‡å­—åˆ—ã‹ã‚‰æ¶ˆã™ï¼ˆç©ºç™½åŒ–ï¼‰
           const fullBlockLength = (cleanSource.indexOf("}", openBraceIndex) - nsIndex) + 1; 
           // æ­£ç¢ºãªçµ‚äº†ä½ç½®ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«å†è¨ˆç®—
           // extractBlockã¯ä¸­èº«ã‚’è¿”ã™ã®ã§ã€å…¨ä½“é•·ã‚’çŸ¥ã‚‹ã«ã¯ä¸­èº«é•·+2({})+nameé•·ãªã©ã‚’è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒé¢å€’
           // ç°¡ä¾¿æ³•: æŠ½å‡ºæ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯ã—ã€Globalè§£ææ™‚ã«ã¯ä½¿ã‚ãªã„
           
           // ä»Šå›ã¯ã€ŒæŠ½å‡ºã—ãŸéƒ¨åˆ†ã‚’ç©ºç™½ã«ç½®æ›ã€ã—ã¦Globalã«æ®‹ã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
           const blockStart = nsIndex;
           // bodyã¯ä¸­èº«ã ã‘ãªã®ã§ã€å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã§ã®çµ‚äº†ä½ç½®ã‚’æ¢ã™å¿…è¦ãŒã‚ã‚‹
           // extractBlockãƒ­ã‚¸ãƒƒã‚¯ã‚’å†åˆ©ç”¨ã—ã¦çµ‚äº†ä½ç½®ã‚’è¦‹ã¤ã‘ã‚‹
           const blockEnd = findBlockEnd(cleanSource, openBraceIndex);
           
           // ç½®æ›ï¼ˆæ–‡å­—åˆ—æ“ä½œã¯ä¸å¤‰ãªã®ã§æ–°ã—ã„æ–‡å­—åˆ—ã‚’ä½œã‚‹ï¼‰
           const before = cleanSource.substring(0, blockStart);
           const after = cleanSource.substring(blockEnd + 1);
           // ç½®æ›ã—ãŸåˆ†ã€æ–‡å­—æ•°ãŒæ¸›ã‚‹ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒç‹‚ã†ã®ã§ã€åŒã˜é•·ã•ã®ç©ºç™½ã§åŸ‹ã‚ã‚‹
           const padding = " ".repeat(blockEnd - blockStart + 1);
           cleanSource = before + padding + after;
           
           cursor = blockEnd + 1;
        } else {
           cursor = openBraceIndex + 1;
        }
      } else {
        cursor = nsIndex + 9;
      }
    }

    // æ®‹ã£ãŸã‚³ãƒ¼ãƒ‰ã¯Global
    namespaceMap.get("Global").push(cleanSource);


    let mermaidDef = "classDiagram\n";

    // --- å„Namespaceã”ã¨ã«ã‚¯ãƒ©ã‚¹ã‚’è§£æ ---
    const allClassBlocks = []; // å¾Œã§ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è§£æã«ä½¿ã†

    // Namespaceã®å‡ºåŠ›é †åºåˆ¶å¾¡ï¼ˆGlobalã‚’æœ€å¾Œã«å›ã™ãªã©ï¼‰
    for (const [nsName, codeBlocks] of namespaceMap) {
      if (codeBlocks.join("").trim() === "") continue;

      let nsDef = "";
      
      codeBlocks.forEach(code => {
        // ã‚¯ãƒ©ã‚¹å®šç¾©æŠ½å‡º
        const regex = /public\s+(?:static\s+)?class\s+(\w+)(?:\s*:\s*([\w, ]+))?/g;
        let match;
        while ((match = regex.exec(code)) !== null) {
          const className = match[1];
          const inheritanceRaw = match[2];

          // é‡è¤‡ãƒã‚§ãƒƒã‚¯: æ—¢ã«å‡¦ç†æ¸ˆã¿ã®ã‚¯ãƒ©ã‚¹ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
          if (processedClasses.has(className)) continue;
          processedClasses.add(className);

          nsDef += `    class ${className}\n`;
          
          // ã‚¹ã‚¿ã‚¤ãƒ«
          if (className.match(/Manager|Controller|Service/)) nsDef += `    style ${className} fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n`;
          else if (className.match(/Config|Data|Model|Body|World/)) nsDef += `    style ${className} fill:#fff9c4,stroke:#fbc02d,stroke-width:2px\n`;

          // ç¶™æ‰¿é–¢ä¿‚ (Namespaceå¤–ã®ã‚¯ãƒ©ã‚¹ã¨ã®é–¢ä¿‚ã‚‚è€ƒæ…®ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯å®šç¾©ã ã‘è¿½åŠ )
          if (inheritanceRaw) {
             const parents = inheritanceRaw.split(',').map(p => p.trim().split('<')[0]);
             parents.forEach(p => {
               // è¦ªã‚¯ãƒ©ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‹ã¯å…¨è§£æå¾Œã˜ã‚ƒãªã„ã¨ç¢ºå®šã—ãªã„ãŒã€Mermaidã¯æœªå®šç¾©ãƒãƒ¼ãƒ‰ã‚‚æç”»ã—ã¦ãã‚Œã‚‹ã®ã§OK
               // ãŸã ã—ã€subgraphå¤–ã¸ã®ç·šã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€å®šç¾©ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã§è¡Œã†ã®ãŒå®‰å…¨
               // ä¸€æ—¦ã“ã“ã§ã¯é…åˆ—ã«ä¿å­˜ã—ã¦ãŠã
               allClassBlocks.push({ type:'inheritance', child: className, parent: p });
             });
          }

          // ã‚¯ãƒ©ã‚¹ã®ä¸­èº«ã‚’æŠ½å‡ºã—ã¦ä¿å­˜ï¼ˆãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è§£æç”¨ï¼‰
          const body = extractBlock(code, match.index + match[0].length);
          if (body) {
            allClassBlocks.push({ type:'class', className, body });
          }
        }
      });

      if (nsDef.trim() !== "") {
        // Globalä»¥å¤–ã¯subgraphã§å›²ã‚€
        if (nsName !== "Global") {
          mermaidDef += `  subgraph "${nsName}"\n`;
          mermaidDef += `    direction TB\n`; // Top to Bottom
          mermaidDef += nsDef;
          mermaidDef += `  end\n`;
        } else {
          mermaidDef += nsDef; // Globalã¯ãã®ã¾ã¾
        }
      }
    }

    // --- ãƒ¡ã‚½ãƒƒãƒ‰ãƒ»ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãƒ»ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®è§£æ ---
    allClassBlocks.forEach(item => {
      // ç¶™æ‰¿é–¢ä¿‚ã®å‡ºåŠ›
      if (item.type === 'inheritance') {
         // è¦ªã‚¯ãƒ©ã‚¹ãŒprocessedClassesã«ã‚ã‚‹å ´åˆã®ã¿æç”»ï¼ˆãƒã‚¤ã‚ºé˜²æ­¢ï¼‰
         if (processedClasses.has(item.parent)) {
            mermaidDef += `  ${item.parent} <|-- ${item.child}\n`;
         }
         return;
      }

      // ã‚¯ãƒ©ã‚¹å®šç¾©å‡¦ç†
      const owner = item.className;
      const body = item.body;

      // ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
      const propRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
      let pMatch;
      while ((pMatch = propRegex.exec(body)) !== null) {
        if (pMatch[1].includes("class ")) continue; 
        mermaidDef += `  ${owner} : +${formatType(pMatch[1])} ${pMatch[2]}\n`;
      }

      // ãƒ¡ã‚½ãƒƒãƒ‰ & ãƒªãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
      const methodRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
      let mMatch;
      const relations = new Map(); // Target -> { solid: Set, dashed: Set }

      while ((mMatch = methodRegex.exec(body)) !== null) {
        const [_, retRaw, mName, argsRaw] = mMatch;
        const dRet = formatType(retRaw);
        const dArgs = formatArgs(argsRaw);
        
        mermaidDef += `  ${owner} : +${mName}(${dArgs}) ${dRet}\n`;

        // æˆ»ã‚Šå€¤
        const rawRetClass = retRaw.split('<')[0].trim().replace('[]','');
        if (processedClasses.has(rawRetClass) && rawRetClass !== owner) {
           addRel(relations, rawRetClass, 'solid', mName);
        }

        // å†…éƒ¨ã‚³ãƒ¼ãƒ‰è§£æ
        const endIdx = mMatch.index + mMatch[0].length;
        const mBody = extractBlock(body, endIdx); // extractBlockã¯æ±ç”¨ãªã®ã§ã“ã“ã§ã‚‚ä½¿ãˆã‚‹
        
        if (mBody) {
           processedClasses.forEach(target => {
             if (target === owner) return;
             
             if (new RegExp(`new\\s+${target}\\s*\\(`).test(mBody)) {
               addRel(relations, target, 'solid', `new ${mName}`);
               // newãŒã‚ã‚‹ãªã‚‰å˜ãªã‚‹returnã¨ã—ã¦ã®è¡¨ç¤ºã¯æ¶ˆã™
               removeRel(relations, target, 'solid', mName);
             }
             else if (new RegExp(`\\b${target}\\s*\\.\\w+`).test(mBody)) {
               addRel(relations, target, 'dashed', `call ${mName}`);
             }
             else if (new RegExp(`\\b${target}\\b`).test(mBody)) {
               addRel(relations, target, 'dashed', mName);
             }
           });
        }
      }

      // æç”»
      relations.forEach((types, target) => {
        if (types.solid.size > 0) {
          mermaidDef += `  ${owner} --> ${target} : ${Array.from(types.solid).join(', ')}\n`;
        }
        
        // é‡è¤‡é™¤å» (solidã«ã‚ã‚‹ã‚‚ã®ã¯dashedã‹ã‚‰æ¶ˆã™)
        types.dashed.forEach(label => {
            const rawLabel = label.replace('call ', '').replace('new ', '');
            let isDuplicated = false;
            types.solid.forEach(s => { if(s.includes(rawLabel)) isDuplicated = true; });
            if(isDuplicated) types.dashed.delete(label);
        });

        if (types.dashed.size > 0) {
          mermaidDef += `  ${owner} ..> ${target} : ${Array.from(types.dashed).join(', ')}\n`;
        }
      });
    });

    await renderMermaid(mermaidDef);
  }

  // --- Helpers ---

  // { ã®ä½ç½®ã‹ã‚‰å¯¾å¿œã™ã‚‹ } ã®ä½ç½®ã‚’æ¢ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
  function findBlockEnd(text, openIndex) {
    let depth = 1;
    let i = openIndex + 1;
    while (i < text.length && depth > 0) {
      if (text[i] === '{') depth++;
      else if (text[i] === '}') depth--;
      i++;
    }
    return i - 1;
  }

  // ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­èº«ã ã‘ã‚’æŠ½å‡º
  function extractBlock(text, start) {
    const openIndex = text.indexOf('{', start);
    if (openIndex === -1) return null;
    const endIndex = findBlockEnd(text, openIndex);
    return text.substring(openIndex + 1, endIndex);
  }

  function addRel(map, target, type, label) {
    if (!map.has(target)) map.set(target, { solid: new Set(), dashed: new Set() });
    map.get(target)[type].add(label);
  }

  function removeRel(map, target, type, label) {
    if (map.has(target)) map.get(target)[type].delete(label);
  }

  function formatType(raw) {
    if (!raw) return "";
    let safe = raw.trim().replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
    return escapeGenerics(safe);
  }

  function formatArgs(raw) {
    if (!raw) return "";
    return escapeGenerics(raw, true);
  }

  function escapeGenerics(str, isArgList = false) {
    let result = "";
    let depth = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str[i];
      if (char === '<') { depth++; result += '~'; }
      else if (char === '>') { depth--; result += '~'; }
      else if (char === ',') {
        if (depth > 0) result += 'ï¼Œ'; 
        else result += isArgList ? ' ' : ' ';
      } else { result += char; }
    }
    return result;
  }

  function removeComments(str) {
    return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
  }

  async function renderMermaid(def) {
    const container = document.getElementById('diagramContainer');
    container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
    try { await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] }); } 
    catch(e) { 
      console.error(e);
      container.innerHTML = `<p style="color:red">Syntax Error</p><textarea style="width:100%;height:300px;">${def}</textarea>`;
    }
  }
</script>
</body>
</html>
