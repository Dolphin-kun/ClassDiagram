<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>C# Repo â†’ Mermaid Visualizer</title>

  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";
    mermaid.initialize({ startOnLoad: false, maxTextSize: 900000 });
    window.mermaid = mermaid;
  </script>
  <script src="https://cdn.jsdelivr.net/npm/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>

  <style>
    /* --- ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®åŸºæœ¬è¨­å®š (å…¨ç”»é¢ã‚¢ãƒ—ãƒªåŒ–) --- */
    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* ç”»é¢å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¦æ­¢ */
      font-family: "Segoe UI", sans-serif;
      background: #f4f6f8;
      color: #333;
    }

    body {
      display: flex;
      flex-direction: column;
      /* ç¸¦ä¸¦ã³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    }

    /* --- ä¸Šéƒ¨æ“ä½œã‚¨ãƒªã‚¢ (å›ºå®šã¾ãŸã¯å†…å®¹ã«å¿œã˜ã¦ä¼¸ç¸®) --- */
    .top-panel {
      padding: 10px 20px;
      flex-shrink: 0;
      /* å›³å½¢ã‚¨ãƒªã‚¢ã«åœ§è¿«ã•ã‚Œã¦ç¸®ã¾ãªã„ã‚ˆã†ã«ã™ã‚‹ */
      background: #f4f6f8;
      border-bottom: 1px solid #ddd;
      max-height: 40vh;
      /* æ“ä½œãƒ‘ãƒãƒ«ãŒå¤§ãããªã‚Šã™ããªã„ã‚ˆã†ã«åˆ¶é™ */
      overflow-y: auto;
      /* æ“ä½œãƒ‘ãƒãƒ«å†…ã ã‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯ */
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 1.2rem;
    }

    .gh-panel {
      background: #24292e;
      color: white;
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 10px;
    }

    .gh-inputs {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      margin-bottom: 5px;
    }

    .gh-input {
      flex: 1;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #444;
      min-width: 150px;
    }

    .btn-gh {
      background: #2ea44f;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
    }

    .gh-note {
      font-size: 0.75rem;
      color: #ccc;
    }

    textarea {
      width: 100%;
      height: 60px;
      padding: 5px;
      font-family: Consolas, monospace;
      border-radius: 4px;
      border: 1px solid #ccc;
      resize: vertical;
      box-sizing: border-box;
      /* ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã‚’å«ã‚ãŸå¹…è¨ˆç®— */
    }

    .controls {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .mermaid {
      height: 100%;
    }

    button {
      padding: 6px 12px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      color: white;
      font-size: 0.9rem;
    }

    .btn-add {
      background: #007bff;
    }

    .btn-save {
      background: #28a745;
    }

    .btn-png {
      background: #6f42c1;
    }

    .btn-reset {
      background: #dc3545;
    }

    .status-msg {
      font-size: 0.85rem;
      font-weight: bold;
      margin-left: 5px;
    }

    .status-success {
      color: #28a745;
    }

    .status-loading {
      color: #e6a700;
    }

    .status-error {
      color: #dc3545;
    }

    .legend {
      font-size: 0.8rem;
      margin-left: auto;
      color: #555;
      display: flex;
      gap: 10px;
    }

    /* --- å›³å½¢è¡¨ç¤ºã‚¨ãƒªã‚¢ (æ®‹ã‚Šã®é«˜ã•ã‚’å…¨ã¦ä½¿ã†) --- */
    #diagramWrapper {
      flex: 1;
      /* æ®‹ã‚Šã®ç©ºé–“ã‚’å æœ‰ */
      min-height: 0;
      /* Flexã‚¢ã‚¤ãƒ†ãƒ ã®ã¯ã¿å‡ºã—é˜²æ­¢ã«å¿…é ˆ */
      padding: 10px 20px 20px 20px;
      /* ä½™ç™½ */
      display: flex;
      flex-direction: column;
    }

    #diagramContainer {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      border: 1px solid #ccc;

      /* è¦ª(diagramWrapper)ã®ä¸­ã§ã„ã£ã±ã„ã«åºƒã’ã‚‹ */
      flex: 1;
      width: 100%;
      height: 100%;

      overflow: hidden;
      /* pan-zoomã®ãŸã‚ */
      position: relative;
    }

    /* SVGå¼·åˆ¶ãƒ•ãƒ«ã‚µã‚¤ã‚º */
    #diagramContainer svg {
      width: 100% !important;
      height: 100% !important;
      max-width: none !important;
    }
  </style>
</head>

<body>

  <div class="top-panel">
    <h1>C# Repo â†’ Mermaid Visualizer</h1>

    <div class="gh-panel">
      <div class="gh-inputs">
        <input type="text" id="repoUrl" class="gh-input" placeholder="https://github.com/user/repo" />
        <input type="password" id="ghToken" class="gh-input" placeholder="GitHub Token (ä»»æ„)" />
        <button onclick="fetchFromGitHub()" class="btn-gh">ğŸš€ ãƒªãƒã‚¸ãƒˆãƒªèª­è¾¼</button>
      </div>
      <div id="ghStatus" class="status-msg"></div>
    </div>

    <textarea id="codeInput" placeholder="// C#ã‚³ãƒ¼ãƒ‰ã‚’æ‰‹å‹•è¿½åŠ "></textarea>

    <div class="controls">
      <button onclick="addCode()" class="btn-add">è§£æã—ã¦è¿½åŠ </button>
      <button onclick="saveToStorage()" class="btn-save">ğŸ’¾ ä¿æŒ</button>
      <button onclick="saveAsPng()" class="btn-png">ğŸ“· PNGä¿å­˜</button>
      <button onclick="saveAsSvg()" class="btn-png">âœ’ï¸ SVGä¿å­˜</button>
      <button onclick="resetAll()" class="btn-reset">ãƒªã‚»ãƒƒãƒˆ</button>
      <span id="saveStatus" class="status-msg status-success" style="display:none">ä¿å­˜å®Œäº†</span>

      <div class="legend">
        <span><b>ãƒ‰ãƒ©ãƒƒã‚°:</b> ç§»å‹•</span>
        <span><b>Ctrl+ãƒ›ã‚¤ãƒ¼ãƒ«:</b> æ‹¡å¤§</span>
      </div>
    </div>
  </div>

  <div id="diagramWrapper">
    <div id="diagramContainer"></div>
  </div>

  <script type="module">
    import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs";

    let fullSourceCode = "";
    let panZoomInstance = null;

    window.addEventListener('load', async () => {
      const savedCode = localStorage.getItem('mermaid_csharp_viz');
      if (savedCode) {
        fullSourceCode = savedCode;
        await analyzeAndRender(fullSourceCode);
      }
    });

    // --- GitHub Fetch ---
    window.fetchFromGitHub = async function () {
      const urlInput = document.getElementById('repoUrl').value.trim();
      const token = document.getElementById('ghToken').value.trim();
      const statusEl = document.getElementById('ghStatus');

      if (!urlInput) {
        statusEl.textContent = "URLã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"; statusEl.className = "status-msg status-error"; return;
      }
      const match = urlInput.match(/github\.com\/([^\/]+\/[^\/]+)/);
      const repoPath = match ? match[1] : urlInput;

      statusEl.textContent = "ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­..."; statusEl.className = "status-msg status-loading";
      const headers = { 'Accept': 'application/vnd.github.v3+json' };
      if (token) headers['Authorization'] = `token ${token}`;

      try {
        const repoRes = await fetch(`https://api.github.com/repos/${repoPath}`, { headers });
        if (!repoRes.ok) throw new Error("Repo not found");
        const repoData = await repoRes.json();
        const defaultBranch = repoData.default_branch;

        const treeRes = await fetch(`https://api.github.com/repos/${repoPath}/git/trees/${defaultBranch}?recursive=1`, { headers });
        const treeData = await treeRes.json();
        const csFiles = treeData.tree.filter(node => node.path.endsWith('.cs') && node.type === 'blob');

        if (csFiles.length === 0) throw new Error("No .cs files found");
        if (csFiles.length > 50 && !confirm(`${csFiles.length} files found. Proceed?`)) {
          statusEl.textContent = "Cancelled"; return;
        }

        statusEl.textContent = `Downloading ${csFiles.length} files...`;
        let fetchedCount = 0;
        const fetchPromises = csFiles.map(async file => {
          let content = "";
          if (token) {
            const blobRes = await fetch(file.url, { headers });
            const blobData = await blobRes.json();
            content = decodeURIComponent(escape(window.atob(blobData.content.replace(/\s/g, ''))));
          } else {
            const rawUrl = `https://raw.githubusercontent.com/${repoPath}/${defaultBranch}/${file.path}`;
            const res = await fetch(rawUrl);
            content = await res.text();
          }
          fetchedCount++;
          statusEl.textContent = `Loading: ${fetchedCount}/${csFiles.length}`;
          return `// File: ${file.path}\n${content}\n`;
        });

        const contents = await Promise.all(fetchPromises);
        fullSourceCode += "\n" + contents.join("\n");
        statusEl.textContent = "Analyzing...";
        await analyzeAndRender(fullSourceCode);
        statusEl.textContent = "Done!"; statusEl.className = "status-msg status-success";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "Error: " + err.message; statusEl.className = "status-msg status-error";
      }
    };

    // --- Buttons ---
    window.addCode = async function () {
      const input = document.getElementById('codeInput');
      if (!input.value.trim()) return;
      fullSourceCode += "\n" + input.value;
      await analyzeAndRender(fullSourceCode);
      input.value = "";
    };

    window.saveToStorage = function () {
      localStorage.setItem('mermaid_csharp_viz', fullSourceCode);
      const msg = document.getElementById('saveStatus');
      msg.style.display = 'inline';
      setTimeout(() => { msg.style.display = 'none'; }, 2000);
    };

    // --- å®‰å®šç‰ˆ PNG ä¿å­˜ ---
    window.saveAsPng = function () {
  const container = document.getElementById('diagramContainer');
  const svgElement = container.querySelector('svg');
  
  if (!svgElement) { 
    alert("å›³ãŒã‚ã‚Šã¾ã›ã‚“"); 
    return; 
  }

  // svg-pan-zoomã®viewportã‚’å–å¾—
  const viewport = svgElement.querySelector('g[class*="svg-pan-zoom_viewport"]');
  
  if (!viewport) {
    alert("å›³ã®æ§‹é€ ãŒæƒ³å®šã¨ç•°ãªã‚Šã¾ã™");
    return;
  }

  // æ–°ã—ã„SVGã‚’ä½œæˆï¼ˆtransformç„¡ã—ï¼‰
  const newSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  newSvg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  
  // viewportã®å†…å®¹ã‚’å…¨ã¦ã‚³ãƒ”ãƒ¼
  const children = viewport.cloneNode(true);
  
  // transformã‚’é™¤å»
  children.removeAttribute('transform');
  children.removeAttribute('style');
  children.setAttribute('class', '');
  
  newSvg.appendChild(children);
  
  // viewBoxã‹ã‚‰å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
  const bbox = viewport.getBBox();
  const w = bbox.width + bbox.x;
  const h = bbox.height + bbox.y;
  
  newSvg.setAttribute("viewBox", `0 0 ${w} ${h}`);
  newSvg.setAttribute("width", w);
  newSvg.setAttribute("height", h);
  
  // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ ï¼ˆMermaidç”¨ï¼‰
  const style = document.createElementNS("http://www.w3.org/2000/svg", "style");
  style.textContent = `
    .actor { fill: #ECECFF; stroke: #9370DB; }
    .noteText { fill: black; font-family: Arial; font-size: 14px; }
    .labelText { fill: black; font-family: Arial; font-size: 14px; }
    .classTitle { font-weight: bold; font-size: 14px; }
    rect { fill: white; stroke: black; }
    line { stroke: black; }
    path { stroke: black; fill: none; }
    text { font-family: Arial; font-size: 14px; fill: black; }
  `;
  newSvg.insertBefore(style, newSvg.firstChild);

  const serializer = new XMLSerializer();
  const svgData = serializer.serializeToString(newSvg);
  
  console.log("ã‚¯ãƒªãƒ¼ãƒ³ãªSVG:", svgData.substring(0, 500));

  // Data URIã¨ã—ã¦åŸ‹ã‚è¾¼ã¿ï¼ˆBlob URLã‚’ä½¿ã‚ãªã„ï¼‰
  const svgBase64 = btoa(unescape(encodeURIComponent(svgData)));
  const dataUri = `data:image/svg+xml;base64,${svgBase64}`;

  const scale = 2;
  const canvas = document.createElement("canvas");
  canvas.width = w * scale;
  canvas.height = h * scale;
  const ctx = canvas.getContext("2d");

  const img = new Image();
  
  img.onload = function () {
    console.log("ç”»åƒèª­ã¿è¾¼ã¿æˆåŠŸ:", img.width, img.height);
    
    // ç™½èƒŒæ™¯
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // æç”»
    ctx.drawImage(img, 0, 0, w * scale, h * scale);
    
    // PNGåŒ–ï¼ˆtoDataURLã‚’ä½¿ç”¨ï¼‰
    try {
      const pngUrl = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = pngUrl;
      a.download = "class_diagram.png";
      a.click();
      console.log("PNGä¿å­˜æˆåŠŸ");
    } catch (e) {
      console.error("PNGå¤‰æ›ã‚¨ãƒ©ãƒ¼:", e);
      alert("PNGç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
    }
  };

  img.onerror = function(e) {
    console.error("ç”»åƒèª­ã¿è¾¼ã¿å¤±æ•—:", e);
    alert("ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
  };

  img.src = dataUri;
};


    // --- SVG ä¿å­˜æ©Ÿèƒ½ ---
    window.saveAsSvg = function () {
      const container = document.getElementById('diagramContainer');
      const originalSvg = container.querySelector('svg');
      if (!originalSvg) { alert("å›³ãŒã‚ã‚Šã¾ã›ã‚“"); return; }

      const viewport = originalSvg.querySelector('.svg-pan-zoom_viewport');
      const targetContent = viewport || originalSvg;
      const bbox = targetContent.getBBox();

      // SVG ã‚’è¤‡è£½
      const clonedSvg = originalSvg.cloneNode(true);

      // ä¸è¦å±æ€§ã®ãƒªã‚»ãƒƒãƒˆ
      clonedSvg.removeAttribute('style');
      clonedSvg.removeAttribute('transform');
      clonedSvg.removeAttribute('width');
      clonedSvg.removeAttribute('height');

      // pan/zoom ã® transform è§£é™¤
      const clonedViewport = clonedSvg.querySelector('.svg-pan-zoom_viewport');
      if (clonedViewport) {
        clonedViewport.setAttribute("transform", "");
        clonedViewport.removeAttribute("style");
      }

      // viewBox ã‚’å›³å½¢ã«ãƒ•ã‚£ãƒƒãƒˆ
      const padding = 20;
      const vX = bbox.x - padding;
      const vY = bbox.y - padding;
      const vW = bbox.width + padding * 2;
      const vH = bbox.height + padding * 2;
      clonedSvg.setAttribute("viewBox", `${vX} ${vY} ${vW} ${vH}`);

      // å¹…/é«˜ã•å±æ€§ã‚‚è¨­å®š
      clonedSvg.setAttribute("width", vW);
      clonedSvg.setAttribute("height", vH);

      // --- â˜…é‡è¦ï¼šstyle ã‚’ defs ã«ã¾ã¨ã‚ã¦ã‚³ãƒ”ãƒ¼ ---
      const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");

      document.querySelectorAll("style").forEach(s => {
        const clone = s.cloneNode(true);
        defs.appendChild(clone);
      });

      clonedSvg.insertBefore(defs, clonedSvg.firstChild);

      // --- SVG ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ ---
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(clonedSvg);

      const blob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = "class_diagram.svg";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      URL.revokeObjectURL(url);
    };

    window.resetAll = async function () {
      if (!confirm("ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ")) return;
      fullSourceCode = "";
      localStorage.removeItem('mermaid_csharp_viz');
      document.getElementById('diagramContainer').innerHTML = "";
      if (panZoomInstance) { panZoomInstance.destroy(); panZoomInstance = null; }
    };

    // --- Logic ---
    async function analyzeAndRender(source) {
      const cleanSource = removeComments(source);
      const classes = new Set();
      const classDefRegex = /public\s+(?:static\s+)?class\s+(\w+)/g;
      let match;
      while ((match = classDefRegex.exec(cleanSource)) !== null) classes.add(match[1]);

      let mermaidDef = "classDiagram\n";
      mermaidDef += "%%{init: {'theme': 'base', 'themeVariables': { 'fontSize': '12px'}}}%%\n";

      classes.forEach(cls => {
        mermaidDef += `  class ${cls}\n`;
        if (cls.match(/Manager|Controller|Service/)) mermaidDef += `  style ${cls} fill:#e3f2fd,stroke:#1565c0,stroke-width:2px\n`;
        else if (cls.match(/Config|Data|Model|Body|World/)) mermaidDef += `  style ${cls} fill:#fff9c4,stroke:#fbc02d,stroke-width:2px\n`;
      });

      const inheritanceRegex = /public\s+(?:static\s+)?class\s+(\w+)\s*:\s*([\w, ]+)/g;
      let iMatch;
      while ((iMatch = inheritanceRegex.exec(cleanSource)) !== null) {
        const child = iMatch[1];
        const parentsRaw = iMatch[2];
        const parents = parentsRaw.split(',').map(p => p.trim());
        parents.forEach(parent => {
          const safeParent = parent.split('<')[0];
          if (classes.has(safeParent)) mermaidDef += `  ${safeParent} <|-- ${child}\n`;
        });
      }

      const classBlocks = extractClassBlocks(cleanSource);
      classBlocks.forEach(block => {
        const owner = block.className;
        if (!classes.has(owner)) return;

        const propRegex = /public\s+(?:static\s+)?(?:readonly\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*(?:\{|=>)/g;
        let pMatch;
        while ((pMatch = propRegex.exec(block.body)) !== null) {
          if (pMatch[1].includes("class ")) continue;
          mermaidDef += `  ${owner} : +${formatType(pMatch[1])} ${pMatch[2]}\n`;
        }

        const methodRegex = /public\s+(?:static\s+)?([\w<>, \?\[\]]+)\s+(\w+)\s*\(([^)]*)\)/g;
        let mMatch;
        const relations = new Map();

        while ((mMatch = methodRegex.exec(block.body)) !== null) {
          const [_, retRaw, mName, argsRaw] = mMatch;
          const dRet = formatType(retRaw);
          const dArgs = formatArgs(argsRaw);
          mermaidDef += `  ${owner} : +${mName}(${dArgs}) ${dRet}\n`;

          const rawRetClass = retRaw.split('<')[0].trim().replace('[]', '');
          if (classes.has(rawRetClass) && rawRetClass !== owner) addRel(relations, rawRetClass, 'solid', mName);

          const endIdx = mMatch.index + mMatch[0].length;
          const body = extractBlock(block.body, endIdx);
          if (body) {
            classes.forEach(target => {
              if (target === owner) return;
              if (new RegExp(`new\\s+${target}\\s*\\(`).test(body)) {
                addRel(relations, target, 'solid', `new ${mName}`);
                removeRel(relations, target, 'solid', mName);
              } else if (new RegExp(`\\b${target}\\s*\\.\\w+`).test(body)) {
                addRel(relations, target, 'dashed', `call ${mName}`);
              } else if (new RegExp(`\\b${target}\\b`).test(body)) {
                addRel(relations, target, 'dashed', mName);
              }
            });
          }
        }

        relations.forEach((types, target) => {
          if (types.solid.size > 0) mermaidDef += `  ${owner} --> ${target} : ${Array.from(types.solid).join(', ')}\n`;
          types.dashed.forEach(label => {
            const rawLabel = label.replace('call ', '').replace('new ', '');
            let isDuplicated = false;
            types.solid.forEach(s => { if (s.includes(rawLabel)) isDuplicated = true; });
            if (isDuplicated) types.dashed.delete(label);
          });
          if (types.dashed.size > 0) mermaidDef += `  ${owner} ..> ${target} : ${Array.from(types.dashed).join(', ')}\n`;
        });
      });

      await renderMermaid(mermaidDef);
    }

    // Utils
    function addRel(map, target, type, label) {
      if (!map.has(target)) map.set(target, { solid: new Set(), dashed: new Set() });
      map.get(target)[type].add(label);
    }
    function removeRel(map, target, type, label) {
      if (map.has(target)) map.get(target)[type].delete(label);
    }
    function formatType(raw) {
      if (!raw) return "";
      // æ”¹è¡Œ(\n)ã‚„ã‚¿ãƒ–ã€é€£ç¶šã™ã‚‹ç©ºç™½ã‚’ã€Œ1ã¤ã®åŠè§’ã‚¹ãƒšãƒ¼ã‚¹ã€ã«ç½®æ›ã—ã¦1è¡Œã«ã™ã‚‹
      let safe = raw.replace(/\s+/g, ' ').trim();
      safe = safe.replace(/\b(readonly|volatile|virtual|override)\b/g, '').trim();
      return escapeGenerics(safe);
    }
    function formatArgs(raw) {
      if (!raw) return "";
      // å¼•æ•°ãƒªã‚¹ãƒˆã®ä¸­ã«ã‚ã‚‹æ”¹è¡Œã‚’ã‚¹ãƒšãƒ¼ã‚¹ã«ç½®æ›ã—ã¦1è¡Œã«ã™ã‚‹
      const oneline = raw.replace(/\s+/g, ' ').trim();
      return escapeGenerics(oneline, true);
    }
    function escapeGenerics(str, isArgList = false) {
      let result = ""; let depth = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char === '<') { depth++; result += '~'; }
        else if (char === '>') { depth--; result += '~'; }
        else if (char === ',') { if (depth > 0) result += 'ï¼Œ'; else result += isArgList ? ' ' : ' '; }
        else { result += char; }
      }
      return result;
    }
    function extractClassBlocks(src) {
      const blocks = [];
      const regex = /public\s+(?:static\s+)?class\s+(\w+)/g;
      let match;
      while ((match = regex.exec(src)) !== null) {
        const body = extractBlock(src, match.index + match[0].length);
        if (body) blocks.push({ className: match[1], body });
      }
      return blocks;
    }
    function extractBlock(text, start) {
      let open = text.indexOf('{', start);
      if (open === -1) return null;
      let d = 1, i = open + 1;
      while (i < text.length && d > 0) {
        if (text[i] === '{') d++; else if (text[i] === '}') d--;
        i++;
      }
      return text.substring(open + 1, i - 1);
    }
    function removeComments(str) {
      return str.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
    }

    async function renderMermaid(def) {
      const container = document.getElementById('diagramContainer');
      if (panZoomInstance) { panZoomInstance.destroy(); panZoomInstance = null; }
      container.innerHTML = `<pre class="mermaid" id="mermaidTarget">${def}</pre>`;
      try {
        await mermaid.run({ nodes: [document.querySelector('#mermaidTarget')] });
        const svgElement = container.querySelector('svg');
        if (svgElement) {
          svgElement.style.maxWidth = "none";
          svgElement.setAttribute("width", "100%");
          svgElement.setAttribute("height", "100%");

          panZoomInstance = svgPanZoom(svgElement, {
            zoomEnabled: true, controlIconsEnabled: true, fit: true, center: true, minZoom: 0.1, maxZoom: 10,
            beforeWheel: function (e) { return e.ctrlKey; }
          });
        }
      } catch (e) {
        console.error(e);
        container.innerHTML = `<p style="color:red">Syntax Error</p><textarea style="width:100%;height:300px;">${def}</textarea>`;
      }
    }
  </script>
</body>

</html>
